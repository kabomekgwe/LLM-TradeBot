# Phase 9 Plan 1: Emergency Safety Controls

**Objective**: Implement production-ready kill switch API, circuit breaker system, and multi-layer position limits with threshold-based triggering for comprehensive trading safety

**Created**: 2025-12-27
**Status**: Ready to execute

---

## Execution Context

### What We're Building

A **layered safety system** with graduated response (Warn → Pause → Kill):

1. **Kill Switch API**: Immediate emergency shutdown endpoint with HMAC authentication
2. **Circuit Breaker**: Automatic trading pause when thresholds breached (drawdown, losses, API errors)
3. **Position Limits**: Hard enforcement at three levels (per-symbol, per-strategy, portfolio-wide)

### Why These Three Components

- **Kill Switch**: Last-resort manual override when human operator detects critical issue
- **Circuit Breaker**: Automatic protection against runaway losses before catastrophic damage
- **Position Limits**: Prevents over-exposure and ensures risk controls always enforced

Each layer independently testable, all three equally critical.

### Architecture Approach

**Reuse Existing Infrastructure**:
- `trading/analytics/risk_calculator.py` - Already has VaR, CVaR, drawdown calculations
- `trading/portfolio/manager.py` - Already has position tracking (`max_position_pct`, `max_symbols`)
- `trading/web/server.py` - Existing FastAPI server for kill switch endpoint

**New Components**:
- `trading/safety/kill_switch.py` - Kill switch state management and API endpoint
- `trading/safety/circuit_breaker.py` - Threshold-based auto-pause logic
- `trading/safety/position_limits.py` - Enhanced multi-layer limit enforcement
- `trading/safety/thresholds.py` - Centralized threshold configuration

### Context References

- **Phase 9 Vision**: `.planning/phases/09-emergency-safety-controls/09-CONTEXT.md`
  - Layered safety (Warn → Pause → Kill)
  - Threshold-based triggers (concrete numbers)
  - No UI (API-only), no historical analysis, no recovery automation

- **Existing Risk Infrastructure**: `trading/analytics/risk_calculator.py`
  - VaR/CVaR calculations, drawdown tracking, risk metrics

- **Existing Position Tracking**: `trading/portfolio/manager.py`
  - Position limits (`max_position_pct`), multi-symbol tracking

---

## Tasks

<task type="create" id="1">
  <name>Create safety module structure and threshold configuration</name>
  <files>
    <create>trading/safety/__init__.py</create>
    <create>trading/safety/thresholds.py</create>
  </files>
  <action>
    Create `trading/safety/` module and centralized threshold configuration.

    **thresholds.py** should define:
    ```python
    @dataclass
    class SafetyThresholds:
        # Drawdown thresholds (%)
        max_daily_drawdown_pct: float = 5.0
        max_weekly_drawdown_pct: float = 10.0
        max_total_drawdown_pct: float = 20.0

        # Loss thresholds
        max_consecutive_losses: int = 10
        max_failed_trades_per_hour: int = 5

        # API error thresholds
        max_api_errors_per_minute: int = 3
        max_order_failures: int = 5

        # Position limit thresholds
        max_position_pct_per_symbol: float = 0.3  # 30% per symbol
        max_position_pct_per_strategy: float = 0.6  # 60% per strategy
        max_total_exposure_pct: float = 0.9  # 90% total
        max_concurrent_positions: int = 10
    ```

    Include validation logic to ensure thresholds are sane (e.g., daily < weekly < total).
  </action>
  <verify>
    - [ ] `trading/safety/__init__.py` created with module exports
    - [ ] `SafetyThresholds` dataclass defined with all threshold fields
    - [ ] Threshold validation logic implemented
    - [ ] Default values are production-ready (conservative)
    - [ ] No syntax errors (`python3 -m py_compile`)
  </verify>
  <done>false</done>
</task>

<task type="create" id="2">
  <name>Implement kill switch API with HMAC authentication</name>
  <files>
    <create>trading/safety/kill_switch.py</create>
    <modify>trading/web/server.py</modify>
  </files>
  <action>
    Implement kill switch state management and secure API endpoint.

    **kill_switch.py** should include:
    ```python
    class KillSwitch:
        def __init__(self, secret_key: str):
            self._active = False
            self._triggered_at: Optional[datetime] = None
            self._triggered_by: Optional[str] = None
            self._reason: Optional[str] = None
            self._secret_key = secret_key

        def trigger(self, reason: str, triggered_by: str) -> bool:
            """Activate kill switch - stops ALL trading immediately."""
            # Set _active = True, record timestamp, reason, user

        def is_active(self) -> bool:
            """Check if kill switch is currently active."""

        def reset(self, reset_by: str) -> bool:
            """Deactivate kill switch - requires manual confirmation."""

        def verify_hmac(self, message: str, signature: str) -> bool:
            """Verify HMAC-SHA256 signature for webhook security."""
            # Use hmac.compare_digest() to prevent timing attacks
    ```

    **server.py** modifications:
    - Add POST `/api/v1/safety/kill-switch/trigger` endpoint
    - Add GET `/api/v1/safety/kill-switch/status` endpoint
    - Add POST `/api/v1/safety/kill-switch/reset` endpoint
    - All endpoints require HMAC authentication header
    - Return 401 if signature invalid, 200 with status if valid

    **Security Requirements**:
    - HMAC-SHA256 signature validation (prevents unauthorized triggers)
    - Secret key from environment variable `KILL_SWITCH_SECRET`
    - Use `hmac.compare_digest()` to prevent timing attacks
    - Log all trigger/reset events with timestamp and user
  </action>
  <verify>
    - [ ] `KillSwitch` class implemented with state management
    - [ ] HMAC signature verification working correctly
    - [ ] Three API endpoints added to FastAPI server
    - [ ] Secret key loaded from environment variable
    - [ ] Timing-attack-safe comparison used (`hmac.compare_digest`)
    - [ ] All trigger/reset events logged
    - [ ] Manual test: trigger via curl with HMAC signature succeeds
    - [ ] Manual test: trigger without signature returns 401
  </verify>
  <done>false</done>
</task>

<task type="create" id="3">
  <name>Implement circuit breaker with threshold-based auto-pause</name>
  <files>
    <create>trading/safety/circuit_breaker.py</create>
  </files>
  <action>
    Implement automatic circuit breaker that monitors thresholds and pauses trading.

    **circuit_breaker.py** should include:
    ```python
    class CircuitBreaker:
        def __init__(self, thresholds: SafetyThresholds, risk_calculator: RiskCalculator):
            self._state = CircuitState.CLOSED  # CLOSED = trading, OPEN = paused
            self._thresholds = thresholds
            self._risk_calculator = risk_calculator

            # Counters for threshold tracking
            self._consecutive_losses = 0
            self._api_errors_last_minute: Deque[datetime] = deque(maxlen=100)
            self._order_failures = 0

        def check_and_update(self, trades: List[TradeRecord], current_equity: float) -> bool:
            """Check all thresholds and trip circuit if breached.

            Returns True if circuit tripped (trading paused).
            """
            # Check drawdown thresholds
            risk_metrics = self._risk_calculator.calculate_risk_metrics(trades)
            if risk_metrics.max_drawdown_pct > self._thresholds.max_daily_drawdown_pct:
                self.trip("Daily drawdown exceeded")
                return True

            # Check consecutive losses
            recent_trades = trades[-self._consecutive_losses:]
            if all(not t.won for t in recent_trades):
                if len(recent_trades) >= self._thresholds.max_consecutive_losses:
                    self.trip("Consecutive losses limit exceeded")
                    return True

            # Check API error rate
            # ... similar threshold checks

            return False

        def trip(self, reason: str):
            """Open circuit (pause trading)."""
            self._state = CircuitState.OPEN
            # Log reason, timestamp

        def reset(self):
            """Close circuit (resume trading) - manual only."""
            self._state = CircuitState.CLOSED

        def is_open(self) -> bool:
            """Returns True if circuit is open (trading paused)."""
    ```

    **Threshold Checks**:
    1. Drawdown: Daily, weekly, total (from RiskCalculator)
    2. Consecutive losses: Track last N trades
    3. API errors: Sliding window (last 60 seconds)
    4. Order failures: Running count since last reset

    **Integration Point**: Called from main trading loop BEFORE placing any order.
  </action>
  <verify>
    - [ ] `CircuitBreaker` class implemented with all threshold checks
    - [ ] Drawdown check integrated with RiskCalculator
    - [ ] Consecutive loss tracking working correctly
    - [ ] API error sliding window implemented
    - [ ] Circuit state transitions (CLOSED ↔ OPEN) working
    - [ ] All trip events logged with reason and timestamp
    - [ ] Unit test: Drawdown breach trips circuit
    - [ ] Unit test: Consecutive losses trip circuit
    - [ ] Unit test: API errors trip circuit
  </verify>
  <done>false</done>
</task>

<task type="create" id="4">
  <name>Implement enhanced position limit enforcement</name>
  <files>
    <create>trading/safety/position_limits.py</create>
    <modify>trading/portfolio/manager.py</modify>
  </files>
  <action>
    Create multi-layer position limit enforcer with per-symbol, per-strategy, and portfolio-wide limits.

    **position_limits.py** should include:
    ```python
    class PositionLimitEnforcer:
        def __init__(self, thresholds: SafetyThresholds):
            self._thresholds = thresholds
            self._positions_by_strategy: Dict[str, List[Position]] = {}

        def check_new_position(
            self,
            symbol: str,
            strategy: str,
            position_size_usd: float,
            current_portfolio_value: float,
        ) -> Tuple[bool, Optional[str]]:
            """Check if new position violates any limits.

            Returns:
                (allowed: bool, rejection_reason: Optional[str])
            """
            # Layer 1: Per-symbol limit
            symbol_exposure_pct = position_size_usd / current_portfolio_value
            if symbol_exposure_pct > self._thresholds.max_position_pct_per_symbol:
                return False, f"Per-symbol limit exceeded: {symbol_exposure_pct:.1%}"

            # Layer 2: Per-strategy limit
            strategy_total = self._get_strategy_exposure(strategy)
            strategy_exposure_pct = (strategy_total + position_size_usd) / current_portfolio_value
            if strategy_exposure_pct > self._thresholds.max_position_pct_per_strategy:
                return False, f"Per-strategy limit exceeded: {strategy_exposure_pct:.1%}"

            # Layer 3: Portfolio-wide limit
            total_exposure = self._get_total_exposure()
            total_exposure_pct = (total_exposure + position_size_usd) / current_portfolio_value
            if total_exposure_pct > self._thresholds.max_total_exposure_pct:
                return False, f"Total exposure limit exceeded: {total_exposure_pct:.1%}"

            # Layer 4: Max concurrent positions
            if self._get_position_count() >= self._thresholds.max_concurrent_positions:
                return False, "Max concurrent positions limit exceeded"

            return True, None

        def _get_strategy_exposure(self, strategy: str) -> float:
            """Calculate total USD exposure for a strategy."""

        def _get_total_exposure(self) -> float:
            """Calculate total USD exposure across all positions."""

        def _get_position_count(self) -> int:
            """Count total open positions."""
    ```

    **portfolio/manager.py** modifications:
    - Integrate `PositionLimitEnforcer.check_new_position()` into `add_position()` method
    - Reject position if any limit exceeded
    - Log rejection reason

    **All Four Layers Must Pass**:
    1. Per-symbol: No more than 30% in any single symbol
    2. Per-strategy: No more than 60% in any single strategy
    3. Portfolio-wide: No more than 90% total exposure
    4. Max positions: No more than 10 concurrent positions
  </action>
  <verify>
    - [ ] `PositionLimitEnforcer` class implemented with 4 limit checks
    - [ ] Per-symbol limit check working correctly
    - [ ] Per-strategy limit check working correctly
    - [ ] Portfolio-wide limit check working correctly
    - [ ] Max concurrent positions check working correctly
    - [ ] Integration into `PortfolioManager.add_position()` complete
    - [ ] Rejection reason logged when limit exceeded
    - [ ] Unit test: Per-symbol limit blocks oversized position
    - [ ] Unit test: Per-strategy limit blocks excessive strategy exposure
    - [ ] Unit test: Portfolio-wide limit blocks over-exposure
    - [ ] Unit test: Max positions limit blocks new position when at capacity
  </verify>
  <done>false</done>
</task>

<task type="create" id="5">
  <name>Integrate safety controls into main trading loop</name>
  <files>
    <modify>trading/manager.py</modify>
    <modify>trading/cli.py</modify>
  </files>
  <action>
    Integrate all three safety layers into the main trading execution flow.

    **manager.py** modifications:
    ```python
    class TradingManager:
        def __init__(self, ...):
            # Initialize safety components
            self.thresholds = SafetyThresholds()
            self.kill_switch = KillSwitch(secret_key=os.getenv("KILL_SWITCH_SECRET"))
            self.circuit_breaker = CircuitBreaker(self.thresholds, risk_calculator)
            self.position_limits = PositionLimitEnforcer(self.thresholds)

        async def execute_trade(self, symbol: str, side: str, amount: float):
            # CHECKPOINT 1: Kill switch check (highest priority)
            if self.kill_switch.is_active():
                self.logger.critical("Kill switch active - ALL TRADING STOPPED")
                return None

            # CHECKPOINT 2: Circuit breaker check
            if self.circuit_breaker.is_open():
                self.logger.warning("Circuit breaker open - trading paused")
                return None

            # CHECKPOINT 3: Position limit check
            allowed, reason = self.position_limits.check_new_position(...)
            if not allowed:
                self.logger.warning(f"Position rejected: {reason}")
                return None

            # All checks passed - proceed with order execution
            order = await self._place_order(symbol, side, amount)

            # CHECKPOINT 4: Update circuit breaker after trade
            if order.filled:
                self.circuit_breaker.check_and_update(...)

            return order
    ```

    **cli.py** modifications:
    - Add `--safety-mode` flag (default: enabled)
    - Add command to check safety status: `python -m trading.cli status --safety`
    - Display kill switch status, circuit breaker state, position limits

    **Execution Order**:
    1. Kill switch (immediate halt)
    2. Circuit breaker (auto-pause)
    3. Position limits (reject oversized positions)
    4. Execute order (if all checks pass)
    5. Update circuit breaker (after execution)
  </action>
  <verify>
    - [ ] Safety components initialized in `TradingManager.__init__()`
    - [ ] Kill switch check at top of `execute_trade()` (highest priority)
    - [ ] Circuit breaker check before order placement
    - [ ] Position limit check before order placement
    - [ ] Circuit breaker updated after successful trade
    - [ ] `--safety-mode` CLI flag added
    - [ ] Safety status command shows all three layers
    - [ ] Integration test: Kill switch blocks all trades
    - [ ] Integration test: Circuit breaker blocks trades when open
    - [ ] Integration test: Position limits reject oversized orders
    - [ ] Integration test: All checks pass → trade executes successfully
  </verify>
  <done>false</done>
</task>

<task type="create" id="6">
  <name>Create comprehensive safety system tests</name>
  <files>
    <create>trading/tests/test_safety_kill_switch.py</create>
    <create>trading/tests/test_safety_circuit_breaker.py</create>
    <create>trading/tests/test_safety_position_limits.py</create>
    <create>trading/tests/test_safety_integration.py</create>
  </files>
  <action>
    Create comprehensive test suite covering all safety components and integration scenarios.

    **test_safety_kill_switch.py** (10+ test methods):
    - Test trigger/reset cycle
    - Test HMAC signature verification (valid/invalid)
    - Test kill switch blocks trading when active
    - Test state persistence
    - Test concurrent trigger attempts

    **test_safety_circuit_breaker.py** (12+ test methods):
    - Test drawdown threshold triggers (daily, weekly, total)
    - Test consecutive loss threshold
    - Test API error rate threshold (sliding window)
    - Test order failure threshold
    - Test circuit reset (manual only)
    - Test multiple threshold breaches (first wins)

    **test_safety_position_limits.py** (10+ test methods):
    - Test per-symbol limit enforcement
    - Test per-strategy limit enforcement
    - Test portfolio-wide limit enforcement
    - Test max concurrent positions limit
    - Test rejection reasons logged correctly
    - Test all four layers checked in order

    **test_safety_integration.py** (8+ test methods):
    - Test layered defense (kill switch → circuit breaker → position limits)
    - Test kill switch overrides circuit breaker
    - Test circuit breaker checked before position limits
    - Test successful trade when all checks pass
    - Test safety status reporting
    - Test threshold configuration validation

    **Coverage Target**: >85% for all `trading/safety/` modules
  </action>
  <verify>
    - [ ] 4 test files created with comprehensive test coverage
    - [ ] All kill switch scenarios tested (trigger, reset, HMAC)
    - [ ] All circuit breaker thresholds tested
    - [ ] All position limit layers tested
    - [ ] Integration tests cover layered defense
    - [ ] All tests pass: `pytest trading/tests/test_safety_*.py -v`
    - [ ] Code coverage >85%: `pytest --cov=trading/safety`
    - [ ] No test warnings or deprecations
  </verify>
  <done>false</done>
</task>

---

## Success Criteria

**Functional Requirements**:
- [ ] Kill switch API accessible via webhook with HMAC authentication
- [ ] Circuit breaker automatically pauses trading when any threshold breached
- [ ] Position limits enforce all four layers (per-symbol, per-strategy, portfolio-wide, max positions)
- [ ] All three safety layers integrate into main trading loop
- [ ] Safety status visible via CLI command

**Quality Requirements**:
- [ ] >85% test coverage for all `trading/safety/` modules
- [ ] All tests pass without warnings
- [ ] No syntax errors or import issues
- [ ] Production-ready threshold defaults (conservative)

**Security Requirements**:
- [ ] HMAC-SHA256 signature verification prevents unauthorized triggers
- [ ] Secret key loaded from environment variable (never hardcoded)
- [ ] Timing-attack-safe comparison used (`hmac.compare_digest`)
- [ ] All safety events logged with timestamp, user, reason

**Integration Requirements**:
- [ ] Kill switch blocks ALL trading when active (highest priority)
- [ ] Circuit breaker blocks trading when open (before position check)
- [ ] Position limits reject oversized orders (before execution)
- [ ] All checks logged with clear rejection reasons

---

## Output Specification

**New Modules Created**:
```
trading/safety/
├── __init__.py
├── thresholds.py          # SafetyThresholds configuration
├── kill_switch.py         # KillSwitch with HMAC auth
├── circuit_breaker.py     # CircuitBreaker with threshold monitoring
└── position_limits.py     # PositionLimitEnforcer (4 layers)
```

**Modified Files**:
```
trading/web/server.py      # Added kill switch API endpoints
trading/portfolio/manager.py   # Integrated position limit checks
trading/manager.py         # Integrated all safety checks
trading/cli.py             # Added safety status command
```

**Test Files Created**:
```
trading/tests/
├── test_safety_kill_switch.py       # 10+ tests
├── test_safety_circuit_breaker.py   # 12+ tests
├── test_safety_position_limits.py   # 10+ tests
└── test_safety_integration.py       # 8+ tests
```

**Dependencies**:
- No new dependencies required (uses stdlib `hmac`, `hashlib`, `dataclasses`)

**Environment Variables**:
```bash
KILL_SWITCH_SECRET=<secret-key-for-hmac>  # Required for API authentication
```

**API Endpoints**:
```
POST /api/v1/safety/kill-switch/trigger
  Headers: X-HMAC-Signature: <hmac-sha256>
  Body: {"reason": "...", "triggered_by": "..."}

GET /api/v1/safety/kill-switch/status
  Headers: X-HMAC-Signature: <hmac-sha256>
  Response: {"active": bool, "triggered_at": timestamp, "reason": "..."}

POST /api/v1/safety/kill-switch/reset
  Headers: X-HMAC-Signature: <hmac-sha256>
  Body: {"reset_by": "..."}
```

**CLI Commands**:
```bash
# Check safety status
python -m trading.cli status --safety

# Expected output:
Kill Switch: INACTIVE
Circuit Breaker: CLOSED (trading enabled)
Position Limits:
  - Per-symbol: 30.0% max
  - Per-strategy: 60.0% max
  - Portfolio-wide: 90.0% max
  - Max positions: 10
```

---

## Checkpoints

- **Checkpoint 1**: After Task 1-2 complete (Kill switch API working)
  - Manual verification: Trigger kill switch via curl with HMAC
  - Verify trading blocked when active

- **Checkpoint 2**: After Task 3-4 complete (Circuit breaker + position limits)
  - Unit tests pass for all threshold checks
  - Position limits reject oversized orders

- **Checkpoint 3**: After Task 5 complete (Integration)
  - Integration tests pass
  - All three layers work together in trading loop

- **Checkpoint 4**: After Task 6 complete (Tests)
  - Full test suite passes
  - Coverage >85%

---

*Plan ready for execution. All tasks follow DRY, KISS, YAGNI principles with threshold-based concrete triggers.*

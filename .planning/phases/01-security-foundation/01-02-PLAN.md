---
phase: 01-security-foundation
plan: 02
type: execute
---

<objective>
Implement atomic state writes to prevent data corruption on crash.

Purpose: Replace direct JSON dump with atomic write pattern (temp file + rename) to guarantee state integrity.
Output: Crash-safe state persistence in `trading/state.py` using atomic file operations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md

**Codebase constraints:**
- Python 3.7+ with asyncio
- State persistence at `trading/state.py:59-62` (save method)
- Uses JSON for state serialization
- State file: `.trading_state.json`

**From codebase analysis (CONCERNS.md):**
- **Bug**: No atomic state writes - state file could be corrupted on crash
- **Trigger**: Process crashes during `state.py:61-62` write operation
- **Root cause**: Direct JSON dump without temp file + rename pattern
- **Fix approach**: Use temp file write + atomic rename pattern

**Prior plan (01-01):**
- Created `.gitignore` (includes `.trading_state*.json` patterns)
- Improved secret masking in config

**Why this matters:**
Trading state contains critical data (positions, orders, P&L). Corruption on crash = data loss = money loss. Atomic writes guarantee state is either fully written or untouched (never partial/corrupt).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement atomic state writes</name>
  <files>trading/state.py</files>
  <action>
Find the `save` method at `trading/state.py:59-62` that currently does direct JSON dump.

**Current pattern** (non-atomic, from CONCERNS.md):
```python
def save(self):
    with open(self.state_file, 'w') as f:
        json.dump(self.data, f)  # If crash here, file is corrupt
```

**Replace with atomic write pattern**:
```python
import os
import tempfile

def save(self):
    """Save state atomically using temp file + rename pattern."""
    # Write to temporary file in same directory (ensures same filesystem)
    state_dir = os.path.dirname(self.state_file) or '.'
    fd, temp_path = tempfile.mkstemp(dir=state_dir, prefix='.trading_state_tmp_', suffix='.json')

    try:
        # Write state to temp file
        with os.fdopen(fd, 'w') as f:
            json.dump(self.data, f, indent=2)

        # Atomic rename - this is the critical operation
        # On POSIX: rename is atomic (overwrites destination atomically)
        # On Windows: may need different approach, but Python 3.3+ handles this
        os.replace(temp_path, self.state_file)

    except Exception as e:
        # Clean up temp file on error
        try:
            os.unlink(temp_path)
        except OSError:
            pass
        raise  # Re-raise original exception
```

**Why this works**:
- `tempfile.mkstemp()` creates temp file in same directory (same filesystem = atomic rename possible)
- Prefix `.trading_state_tmp_` helps identify temp files (and .gitignore already excludes them)
- `os.replace()` is atomic on all platforms (Python 3.3+)
- If crash during write → temp file corrupt, original state file untouched
- If crash during rename → atomic operation, either completes or doesn't
- Exception handling cleans up temp file on error

**Add at top of file** (if not already present):
```python
import os
import tempfile
```

**Test edge cases**:
- Ensure state_dir exists before mkstemp
- Handle missing directory gracefully
  </action>
  <verify>
- Read `trading/state.py` - find modified save method
- Uses tempfile.mkstemp() in same directory as state file
- Uses os.replace() for atomic rename
- Exception handling cleans up temp file
- Imports added: `import os`, `import tempfile`
  </verify>
  <done>
- State save method uses atomic write pattern
- Temp file created in same directory as target
- os.replace() guarantees atomic rename
- Exception handling prevents temp file leak
- State corruption on crash is now impossible
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `trading/state.py` has atomic save implementation
- [ ] Code uses tempfile.mkstemp() + os.replace() pattern
- [ ] Exception handling cleans up temp file on error
- [ ] No regressions (state still loads/saves correctly)
</verification>

<success_criteria>

- Task completed
- Atomic write pattern implemented correctly
- State corruption impossible on crash
- Temp files cleaned up on error
  </success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-02-SUMMARY.md`:

# Phase 1 Plan 2: Atomic State Persistence Summary

**[One-liner describing what shipped]**

## Accomplishments

- Implemented atomic state writes using temp file + rename pattern
- Guaranteed crash-safe state persistence

## Files Created/Modified

- `trading/state.py` - Atomic save method with tempfile + os.replace

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 01-03-PLAN.md (Credential & Validation)
</output>

---
phase: 01-security-foundation
plan: 03
type: execute
---

<objective>
Refactor credential management and implement input validation framework.

Purpose: Replace plain text API keys with environment variable pattern and add validation at all external boundaries.
Output: Secure credential loading from environment, validation utilities for external inputs.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md
@.planning/phases/01-security-foundation/01-02-SUMMARY.md

**Codebase constraints:**
- Python 3.7+ with dataclasses
- Configuration at `trading/config.py:22-23` (API credentials as dataclass fields)
- Credentials passed to CCXT at `trading/config.py:51-52`
- Multiple providers: Binance Futures/Spot, Kraken, Coinbase, Alpaca

**From codebase analysis (CONCERNS.md):**
- **Security issue**: Plain text API keys in memory, exposed in logs/errors
- **Files**: `trading/config.py:22-23`, `trading/config.py:51-52`
- **Current mitigation**: Only `__repr__` masking (insufficient)
- **Recommendation**: Use environment variables with validation

**From STACK.md:**
- Uses `python-dotenv` for .env loading (check requirements.txt)
- CCXT library requires api_key and secret as constructor arguments

**Prior plans:**
- 01-01: Created `.gitignore` (protects .env files), improved secret masking
- 01-02: Implemented atomic state writes

**Why this matters:**
- Credentials must never be hardcoded or logged
- Environment variables are standard for 12-factor apps
- Validation prevents silent failures from missing/invalid credentials
- Input validation blocks injection attacks at boundaries
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor credential management to environment variables</name>
  <files>trading/config.py, .env.example</files>
  <action>
Modify `trading/config.py` to load API credentials from environment variables instead of accepting them as parameters.

**Current pattern** (from CONCERNS.md):
```python
@dataclass
class ExchangeConfig:
    api_key: str
    secret: str
```

**New pattern** (environment variables):
```python
import os
from typing import Optional

@dataclass
class ExchangeConfig:
    exchange_name: str

    def __post_init__(self):
        """Load credentials from environment on initialization."""
        env_prefix = self.exchange_name.upper().replace('-', '_')
        self.api_key = os.getenv(f'{env_prefix}_API_KEY')
        self.secret = os.getenv(f'{env_prefix}_API_SECRET')

        # Validate credentials are present
        if not self.api_key or not self.secret:
            raise ValueError(
                f"Missing credentials for {self.exchange_name}. "
                f"Set {env_prefix}_API_KEY and {env_prefix}_API_SECRET environment variables."
            )

    def __repr__(self):
        # Use improved masking from 01-01
        masked_secret = "***REDACTED***"
        masked_key = f"{self.api_key[:8]}..." if self.api_key else None
        return f"ExchangeConfig(exchange={self.exchange_name}, api_key={masked_key}, secret={masked_secret})"
```

**Environment variable naming**:
- Binance Futures: `BINANCE_FUTURES_API_KEY`, `BINANCE_FUTURES_API_SECRET`
- Binance Spot: `BINANCE_SPOT_API_KEY`, `BINANCE_SPOT_API_SECRET`
- Kraken: `KRAKEN_API_KEY`, `KRAKEN_API_SECRET`
- Coinbase: `COINBASE_API_KEY`, `COINBASE_API_SECRET`
- Alpaca: `ALPACA_API_KEY`, `ALPACA_API_SECRET`

**Create `.env.example`** template:
```bash
# Exchange API Credentials
# Copy to .env and fill in your actual keys

# Binance Futures
BINANCE_FUTURES_API_KEY=your_key_here
BINANCE_FUTURES_API_SECRET=your_secret_here

# Binance Spot
BINANCE_SPOT_API_KEY=your_key_here
BINANCE_SPOT_API_SECRET=your_secret_here

# Kraken
KRAKEN_API_KEY=your_key_here
KRAKEN_API_SECRET=your_secret_here

# Coinbase
COINBASE_API_KEY=your_key_here
COINBASE_API_SECRET=your_secret_here

# Alpaca
ALPACA_API_KEY=your_key_here
ALPACA_API_SECRET=your_secret_here

# Paper Trading (no real credentials needed)
PAPER_API_KEY=test
PAPER_API_SECRET=test
```

**Update anywhere ExchangeConfig is instantiated**:
- Old: `ExchangeConfig(api_key="...", secret="...")`
- New: `ExchangeConfig(exchange_name="binance-futures")`

**Ensure python-dotenv is used**:
- Check if `from dotenv import load_dotenv` exists at app entry point
- If not, add `load_dotenv()` call before any config loading
- This reads .env file into environment variables

**Why environment variables**:
- Standard 12-factor app pattern
- Never committed to git (.gitignore blocks .env)
- Easy to rotate (just update .env)
- Works in all deployment environments (local, docker, cloud)
  </action>
  <verify>
- `trading/config.py` loads credentials from environment in __post_init__
- Raises ValueError if credentials missing (fail-fast)
- `.env.example` created with all exchange templates
- No hardcoded credentials in code
- ExchangeConfig constructor takes only exchange_name
  </verify>
  <done>
- Credentials loaded exclusively from environment variables
- Clear error messages if credentials missing
- .env.example provides template for users
- No credentials visible in code, logs, or errors
- Follows 12-factor app security principles
  </done>
</task>

<task type="auto">
  <name>Task 2: Add input validation framework at boundaries</name>
  <files>trading/validation.py (new), trading/config.py, trading/cli.py</files>
  <action>
Create `trading/validation.py` with validation utilities for external inputs (API parameters, user commands, market data).

**Create validation module**:
```python
"""Input validation utilities for security boundaries."""

from typing import Any, Optional
import re

class ValidationError(Exception):
    """Raised when input validation fails."""
    pass

def validate_symbol(symbol: str) -> str:
    """
    Validate trading symbol format.

    Args:
        symbol: Trading pair symbol (e.g., "BTC/USDT", "ETH-USD")

    Returns:
        Validated symbol in uppercase

    Raises:
        ValidationError: If symbol format invalid

    Why: Prevents injection attacks via symbol parameter to exchange APIs.
    """
    if not symbol or not isinstance(symbol, str):
        raise ValidationError("Symbol must be a non-empty string")

    # Allow alphanumeric, slash, dash, underscore only
    if not re.match(r'^[A-Z0-9/_-]+$', symbol.upper()):
        raise ValidationError(f"Invalid symbol format: {symbol}")

    if len(symbol) > 20:
        raise ValidationError(f"Symbol too long: {symbol}")

    return symbol.upper()

def validate_timeframe(timeframe: str) -> str:
    """
    Validate timeframe string.

    Args:
        timeframe: Candle timeframe (e.g., "1m", "5m", "1h", "1d")

    Returns:
        Validated timeframe

    Raises:
        ValidationError: If timeframe invalid

    Why: Prevents unexpected values being passed to exchange APIs.
    """
    valid_timeframes = ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '12h', '1d', '1w']

    if timeframe not in valid_timeframes:
        raise ValidationError(f"Invalid timeframe: {timeframe}. Must be one of: {valid_timeframes}")

    return timeframe

def validate_positive_number(value: Any, name: str = "value") -> float:
    """
    Validate positive number (for amounts, prices, limits).

    Args:
        value: Number to validate
        name: Parameter name for error messages

    Returns:
        Validated float value

    Raises:
        ValidationError: If not a positive number

    Why: Prevents negative amounts, zero prices, infinity values.
    """
    try:
        num = float(value)
    except (TypeError, ValueError):
        raise ValidationError(f"{name} must be a number, got: {value}")

    if num <= 0:
        raise ValidationError(f"{name} must be positive, got: {num}")

    if not float('-inf') < num < float('inf'):
        raise ValidationError(f"{name} must be finite, got: {num}")

    return num

def validate_limit(limit: Optional[int], max_limit: int = 1000) -> Optional[int]:
    """
    Validate result limit parameter.

    Args:
        limit: Number of results to return
        max_limit: Maximum allowed limit

    Returns:
        Validated limit or None

    Raises:
        ValidationError: If limit invalid

    Why: Prevents memory exhaustion from excessive result sets.
    """
    if limit is None:
        return None

    try:
        limit = int(limit)
    except (TypeError, ValueError):
        raise ValidationError(f"Limit must be an integer, got: {limit}")

    if limit < 1:
        raise ValidationError(f"Limit must be at least 1, got: {limit}")

    if limit > max_limit:
        raise ValidationError(f"Limit cannot exceed {max_limit}, got: {limit}")

    return limit
```

**Apply validation at boundaries**:

1. **In `trading/config.py`** - validate exchange names:
```python
from trading.validation import ValidationError

def validate_exchange_name(name: str) -> str:
    """Validate exchange name against supported providers."""
    valid_exchanges = ['binance-futures', 'binance-spot', 'kraken', 'coinbase', 'alpaca', 'paper']
    if name not in valid_exchanges:
        raise ValidationError(f"Unknown exchange: {name}. Supported: {valid_exchanges}")
    return name
```

2. **In `trading/cli.py`** - validate user commands:
Add validation imports at top:
```python
from trading.validation import validate_symbol, validate_timeframe, ValidationError
```

Apply in command handlers where user input is processed.

**Why input validation**:
- Defense in depth - validate at every boundary
- Prevents injection attacks (SQL injection, command injection via symbols)
- Catches errors early (fail-fast principle)
- Clear error messages guide users
- Protects against malformed API responses

**Don't validate**:
- Internal function parameters (trust internal code)
- Already-validated data (don't double-validate)
- Types (use type hints + static analysis instead)
  </action>
  <verify>
- `trading/validation.py` exists with validation functions
- Functions have clear docstrings explaining "Why" (security rationale)
- ValidationError exception defined
- Imports added to `trading/config.py` and relevant CLI commands
- No generic exception catches (use specific ValidationError)
  </verify>
  <done>
- Input validation framework created
- Validation applied at external boundaries (user input, API parameters)
- Clear security-focused error messages
- Protection against injection attacks and malformed input
- Follows fail-fast principle (validate early, fail with clear errors)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ExchangeConfig loads credentials from environment variables
- [ ] Clear error if credentials missing
- [ ] `.env.example` exists with all exchange templates
- [ ] `trading/validation.py` created with validation utilities
- [ ] Validation applied at boundaries in config and CLI
- [ ] No hardcoded credentials remain in code
</verification>

<success_criteria>

- All tasks completed
- Credentials managed exclusively via environment variables
- Input validation framework protects all external boundaries
- Clear error messages guide users
- Phase 1 (Security Foundation) complete - ready for Phase 2
  </success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-03-SUMMARY.md`:

# Phase 1 Plan 3: Credential & Validation Summary

**[One-liner describing what shipped]**

## Accomplishments

- Refactored credential management to environment variables
- Created input validation framework for security boundaries
- Applied validation at external boundaries (config, CLI)

## Files Created/Modified

- `trading/config.py` - Environment variable credential loading
- `.env.example` - Credential template for all exchanges
- `trading/validation.py` (new) - Input validation utilities
- `trading/cli.py` - Applied validation at command boundaries

## Decisions Made

- Environment variable naming: `{EXCHANGE}_API_KEY`, `{EXCHANGE}_API_SECRET`
- Validation philosophy: Fail-fast at boundaries, trust internal code
- [Other decisions]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

**Phase 1 Complete!** All security foundation tasks finished.

Ready for Phase 2: Complete Agent Implementations
</output>

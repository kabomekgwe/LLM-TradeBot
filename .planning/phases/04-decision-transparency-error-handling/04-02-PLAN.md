---
phase: 04-decision-transparency-error-handling
plan: 02
type: execute
---

<objective>
Replace print() statements with structured logging and add async timeouts.

Purpose: Migrate all 79 print() statements to structured logging with contextual information, and add timeout handling to all async operations.
Output: All print() statements replaced with logger calls, timeout decorators on async functions, improved observability and resilience.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-decision-transparency-error-handling/DISCOVERY.md
@.planning/phases/04-decision-transparency-error-handling/04-01-SUMMARY.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/ARCHITECTURE.md

**Codebase constraints:**
- Python 3.7+ with asyncio
- 8-agent async pipeline
- CCXT exchange API integration
- File-based state persistence

**From codebase analysis (CONCERNS.md):**
- **Current issue**: 79 print() statements mixed with logging throughout codebase
- **Current issue**: No timeout handling on async operations (system hangs on network issues)
- **Files affected**: `trading/agents/data_sync.py:59` uses `asyncio.gather()` with no timeout
- **Impact**: Unstructured logs hard to parse, system hangs on API failures

**From DISCOVERY.md:**
- Print() replacement: Use logger.info/warning/error with extra dict
- Log levels: DEBUG (diagnostics), INFO (operations), WARNING (recoverable), ERROR (failures)
- Timeouts: asyncio.wait_for() or asyncio.timeout() context manager (Python 3.11+)
- Recommended timeouts: OHLCV 30s, ticker 10s, orders 15s, agents 60s
- Decorator pattern for timeout reusability

**Prior work:**
- Plan 04-01 completed - Exception hierarchy and logging infrastructure created

**Why this matters:**
Print statements vanish in production environments and provide no context. Without timeouts, a single slow API call can freeze the entire trading system, missing trade opportunities or failing to exit positions.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timeout utilities</name>
  <files>trading/utils/timeout.py (new)</files>
  <action>
Create reusable timeout utilities for async operations.

**1. Create `trading/utils/timeout.py`:**
```python
"""
Timeout utilities for async operations.

Provides decorators and context managers for adding timeouts to async functions.
"""

import asyncio
import functools
from typing import TypeVar, Callable, Any

from trading.exceptions import AgentTimeoutError
from trading.logging_config import get_logger

logger = get_logger(__name__)

T = TypeVar("T")


def with_timeout(seconds: float, error_class=AgentTimeoutError):
    """
    Decorator to add timeout to async functions.

    Args:
        seconds: Timeout in seconds
        error_class: Exception class to raise on timeout (default: AgentTimeoutError)

    Returns:
        Decorated async function

    Example:
        @with_timeout(30.0)
        async def fetch_data(symbol: str):
            return await exchange.fetch_ohlcv(symbol)
    """
    def decorator(func: Callable[..., Any]) -> Callable[..., Any]:
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await asyncio.wait_for(func(*args, **kwargs), timeout=seconds)
            except asyncio.TimeoutError:
                func_name = func.__name__
                logger.error(
                    "function_timeout",
                    extra={
                        "function": func_name,
                        "timeout_seconds": seconds,
                        "args": str(args)[:100],  # Truncate for logging
                    },
                )
                raise error_class(f"{func_name} exceeded {seconds}s timeout")

        return wrapper

    return decorator


async def with_timeout_and_retry(
    coro, timeout: float, retries: int = 1, retry_delay: float = 1.0
) -> Any:
    """
    Execute async function with timeout and retry logic.

    Args:
        coro: Coroutine to execute
        timeout: Timeout in seconds
        retries: Number of retry attempts (default: 1)
        retry_delay: Delay between retries in seconds (default: 1.0)

    Returns:
        Result from coroutine

    Raises:
        AgentTimeoutError: If all retries exhausted

    Example:
        result = await with_timeout_and_retry(
            exchange.fetch_ohlcv(symbol, "5m"),
            timeout=30.0,
            retries=2
        )
    """
    last_error = None

    for attempt in range(retries + 1):
        try:
            return await asyncio.wait_for(coro, timeout=timeout)
        except asyncio.TimeoutError as e:
            last_error = e
            if attempt < retries:
                logger.warning(
                    "timeout_retry",
                    extra={
                        "attempt": attempt + 1,
                        "retries": retries,
                        "timeout_seconds": timeout,
                        "retry_delay": retry_delay,
                    },
                )
                await asyncio.sleep(retry_delay)
            else:
                logger.error(
                    "timeout_exhausted",
                    extra={
                        "attempts": attempt + 1,
                        "timeout_seconds": timeout,
                    },
                )

    raise AgentTimeoutError(f"All {retries + 1} attempts exhausted (timeout: {timeout}s)")
```

**What to avoid:**
- Don't use timeouts shorter than 1s (network latency)
- Don't retry order placements (could duplicate orders)
- Don't catch TimeoutError and ignore it
- Don't use timeout on local operations (only external calls)

**Why these choices:**
- Decorator pattern: Clean syntax, reusable across functions
- with_timeout_and_retry: For operations where retries are safe (data fetches)
- Logging on timeout: Helps diagnose which operations are slow
- AgentTimeoutError: Specific exception type for timeout failures
  </action>
  <verify>
1. File created: `trading/utils/timeout.py` exists
2. Import works: `python -c "from trading.utils.timeout import with_timeout; print('OK')"`
3. No syntax errors: `python -m py_compile trading/utils/timeout.py` succeeds
  </verify>
  <done>
- Timeout utility module created
- with_timeout decorator for async functions
- with_timeout_and_retry for retriable operations
- Comprehensive logging on timeout events
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate print() statements and add timeouts to agents</name>
  <files>trading/agents/*.py (all 8 agents), trading/manager.py, trading/cli.py</files>
  <action>
Replace all print() statements with structured logging and add timeout decorators.

**Priority files (79 print statements total):**

**1. Update `trading/agents/base_agent.py`:**
```python
# Add at top
from trading.logging_config import get_logger, DecisionContext
from trading.utils.timeout import with_timeout

# Add to BaseAgent class
class BaseAgent:
    def __init__(self, config):
        self.config = config
        self.logger = get_logger(self.__class__.__name__)  # Module-level logger

    @with_timeout(60.0)  # 60s timeout for agent execution
    async def execute(self, context):
        """Execute agent logic with timeout."""
        raise NotImplementedError("Subclasses must implement execute()")
```

**2. Example migration in agents (replace print with logger):**
```python
# ❌ Before (print statement)
print(f"Bull agent vote: {vote}, confidence: {confidence}")

# ✅ After (structured logging)
self.logger.info(
    "agent_vote",
    extra={
        **DecisionContext.get_extra(),  # Include decision_id
        "agent": self.get_agent_name(),
        "vote": vote,
        "confidence": confidence,
        "direction": "bullish",
        "factors": factors,
    },
)
```

**3. Add timeouts to DataSyncAgent async operations:**
```python
# In trading/agents/data_sync.py
from trading.utils.timeout import with_timeout_and_retry

# Replace asyncio.gather() with timeout
async def execute(self, context):
    symbol = context.get("symbol")

    # Fetch OHLCV with timeout and retry
    ohlcv_5m = await with_timeout_and_retry(
        self.exchange.fetch_ohlcv(symbol, "5m", limit=100),
        timeout=30.0,
        retries=2,
    )

    ohlcv_15m = await with_timeout_and_retry(
        self.exchange.fetch_ohlcv(symbol, "15m", limit=100),
        timeout=30.0,
        retries=2,
    )

    # Fetch ticker with timeout (no retry needed)
    ticker = await asyncio.wait_for(
        self.exchange.fetch_ticker(symbol),
        timeout=10.0,
    )

    self.logger.info(
        "data_sync_complete",
        extra={
            **DecisionContext.get_extra(),
            "symbol": symbol,
            "ohlcv_5m_candles": len(ohlcv_5m),
            "ohlcv_15m_candles": len(ohlcv_15m),
            "ticker_price": ticker["last"],
        },
    )

    return {
        "ohlcv_data": {"5m": ohlcv_5m, "15m": ohlcv_15m},
        "ticker": ticker,
    }
```

**4. Update TradingManager to use DecisionContext:**
```python
# In trading/manager.py
import uuid
from trading.logging_config import DecisionContext

async def run_trading_loop(self, symbol: str):
    """Run trading loop with decision context."""
    # Generate decision ID for tracing
    decision_id = str(uuid.uuid4())
    DecisionContext.set_decision_id(decision_id)

    self.logger.info(
        "decision_start",
        extra={
            **DecisionContext.get_extra(),
            "symbol": symbol,
        },
    )

    # ... rest of trading loop

    # Clear context after loop
    DecisionContext.clear()
```

**Migration checklist (apply to all files with print()):**
- [ ] `trading/cli.py` - Replace status/position prints
- [ ] `trading/manager.py` - Replace loop progress prints
- [ ] `trading/agents/data_sync.py` - Replace data fetch prints + add timeouts
- [ ] `trading/agents/quant_analyst.py` - Replace indicator prints
- [ ] `trading/agents/predict.py` - Replace prediction prints
- [ ] `trading/agents/bull.py` - Replace vote prints
- [ ] `trading/agents/bear.py` - Replace vote prints
- [ ] `trading/agents/decision_core.py` - Replace decision prints
- [ ] `trading/agents/risk_audit.py` - Replace veto prints
- [ ] `trading/agents/execution.py` - Replace order prints + add timeout to create_order

**Log level guide:**
- DEBUG: Indicator values, intermediate calculations
- INFO: Agent votes, decisions, order execution, data fetches
- WARNING: Rate limits, retries, low confidence
- ERROR: API failures, agent errors, order rejections
- CRITICAL: Circuit breaker trips, state corruption

**What to avoid:**
- Don't remove useful information from logs (keep context)
- Don't add timeouts to synchronous code (only async operations)
- Don't retry order placements (could duplicate orders)
- Don't log sensitive data (API keys, secrets)

**Why these choices:**
- Structured logging: Machine-parseable, enables log aggregation and analysis
- DecisionContext: Correlates all logs for a single trading decision
- Timeouts on external calls: Prevents system hangs on network issues
- Module-level loggers: Easy to filter logs by component
  </action>
  <verify>
1. No print() remains: `grep -r "print(" trading/ --include="*.py" | grep -v "# print"` returns empty
2. All agents use logger: `grep -r "self.logger" trading/agents/*.py` shows usage
3. Timeouts on async calls: Check DataSyncAgent and ExecutionAgent have timeouts
4. DecisionContext used: TradingManager sets decision_id before loop
5. No syntax errors: `python -m py_compile trading/agents/*.py trading/manager.py trading/cli.py` succeeds
  </verify>
  <done>
- All 79 print() statements replaced with structured logging
- DecisionContext integrated for decision tracing
- Timeouts added to all external async operations
- Agent execution protected with 60s timeout
- CCXT operations protected with appropriate timeouts
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] trading/utils/timeout.py created with decorators
- [ ] All print() statements replaced (0 remaining)
- [ ] All agents use self.logger with structured logging
- [ ] DecisionContext integrated in TradingManager
- [ ] Timeouts added to DataSyncAgent CCXT calls
- [ ] Timeouts added to ExecutionAgent order placement
- [ ] All agents have @with_timeout on execute()
- [ ] Log messages include contextual extra dict
</verification>

<success_criteria>

- Both tasks completed successfully
- Print() statements eliminated (79 → 0)
- Structured JSON logging throughout
- Async operations protected with timeouts
- Decision correlation via DecisionContext
- Ready for Plan 04-03 (replace generic exceptions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-decision-transparency-error-handling/04-02-SUMMARY.md`:

# Phase 4 Plan 2: Logging Migration & Timeouts Summary

**[One-liner describing what shipped]**

## Accomplishments

- Migrated all 79 print() statements to structured logging
- Added timeout utilities with decorator pattern
- Integrated DecisionContext for decision tracing
- [Additional accomplishments]

## Files Created/Modified

- `trading/utils/timeout.py` (new) - Timeout decorators and retry logic
- `trading/agents/base_agent.py` - Added logger and timeout to base class
- `trading/agents/*.py` (8 files) - Migrated print to logger, added timeouts
- `trading/manager.py` - Integrated DecisionContext
- `trading/cli.py` - Migrated print to logger

## Decisions Made

- 60s timeout for agent execution (prevents infinite loops)
- 30s timeout for OHLCV fetches with 2 retries
- 10s timeout for ticker/balance (fast operations)
- 15s timeout for order placement (no retry)
- DecisionContext for correlation tracking
- [Other decisions]

## Deviations from Plan

[Document any deviations using deviation rules, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Verification Results

[Results of verification checklist]

## Next Step

**Ready for Plan 04-03**: Replace generic exception handling with specific exception types
</output>

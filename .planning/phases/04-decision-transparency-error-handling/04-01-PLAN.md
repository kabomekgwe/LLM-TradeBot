---
phase: 04-decision-transparency-error-handling
plan: 01
type: execute
---

<objective>
Create exception hierarchy and structured logging foundation.

Purpose: Establish reusable exception types and JSON logging infrastructure for the entire codebase.
Output: Custom exception hierarchy in trading/exceptions.py, structured logging configuration in trading/logging_config.py, updated base agent with logging support.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-decision-transparency-error-handling/DISCOVERY.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Codebase constraints:**
- Python 3.7+ (async/await required)
- Existing logging module usage (extend, don't replace)
- 8-agent system with BaseAgent pattern
- File-based state persistence
- Multi-provider exchange abstraction

**From codebase analysis (CONCERNS.md):**
- **Current issue**: 50+ generic `except Exception as e:` catches throughout codebase
- **Current issue**: 79 print() statements instead of proper logging
- **Impact**: Masks specific errors, makes debugging harder, prevents proper recovery
- **Files affected**: `trading/cli.py`, `trading/manager.py`, all agents, all providers

**From DISCOVERY.md:**
- Exception hierarchy: TradingBotError root with 4 categories (ConfigurationError, APIError, RiskViolationError, AgentError, StateError)
- Structured logging: python-json-logger for JSON output, correlation via decision_id
- Log levels: DEBUG (diagnostics), INFO (operations), WARNING (recoverable), ERROR (failures), CRITICAL (system-threatening)
- Organization: `trading/exceptions.py` for all custom exceptions, `trading/logging_config.py` for logger setup

**Why this matters:**
Without proper exception types, all errors look the same and recovery is impossible. Without structured logging, debugging production issues requires grep'ing through unstructured text. This foundation enables all subsequent transparency improvements.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom exception hierarchy</name>
  <files>trading/exceptions.py (new)</files>
  <action>
Create comprehensive exception hierarchy for the entire trading bot system.

**1. Create `trading/exceptions.py`:**
```python
"""
Custom exception hierarchy for LLM-TradeBot.

All trading bot exceptions derive from TradingBotError for easy catching.
Organized by domain: Configuration, API, Risk, Agent, State.
"""


class TradingBotError(Exception):
    """Base exception for all trading bot errors."""
    pass


# ============================================================================
# Configuration Errors
# ============================================================================

class ConfigurationError(TradingBotError):
    """Configuration-related errors (env vars, settings)."""
    pass


class MissingCredentialError(ConfigurationError):
    """Required API credential not found in environment."""
    pass


class InvalidConfigValueError(ConfigurationError):
    """Configuration value invalid or out of range."""
    pass


# ============================================================================
# API Errors (Exchange, Sentiment, External Services)
# ============================================================================

class APIError(TradingBotError):
    """External API communication errors."""
    pass


class ExchangeConnectionError(APIError):
    """Cannot connect to exchange API."""
    pass


class RateLimitExceededError(APIError):
    """Exchange rate limit exceeded."""
    pass


class OrderRejectedError(APIError):
    """Exchange rejected order (insufficient balance, invalid params, etc.)."""
    pass


class InvalidSymbolError(APIError):
    """Trading symbol not supported by exchange."""
    pass


# ============================================================================
# Risk Management Errors (Safety Violations)
# ============================================================================

class RiskViolationError(TradingBotError):
    """Risk management constraint violations."""
    pass


class InsufficientBalanceError(RiskViolationError):
    """Insufficient balance to execute trade."""
    pass


class PositionLimitExceededError(RiskViolationError):
    """Position would exceed max position size."""
    pass


class DailyDrawdownExceededError(RiskViolationError):
    """Daily drawdown limit exceeded."""
    pass


class CircuitBreakerTrippedError(RiskViolationError):
    """Circuit breaker activated due to excessive losses."""
    pass


class ConfidenceThresholdError(RiskViolationError):
    """Decision confidence below minimum threshold."""
    pass


# ============================================================================
# Agent Errors (Analysis, Prediction, Decision)
# ============================================================================

class AgentError(TradingBotError):
    """Agent execution errors."""
    pass


class InvalidIndicatorDataError(AgentError):
    """Indicator data is invalid, incomplete, or missing."""
    pass


class ModelPredictionError(AgentError):
    """ML model prediction failed."""
    pass


class AgentTimeoutError(AgentError):
    """Agent execution exceeded timeout."""
    pass


class InsufficientMarketDataError(AgentError):
    """Not enough market data for analysis (need 100+ candles)."""
    pass


# ============================================================================
# State Persistence Errors
# ============================================================================

class StateError(TradingBotError):
    """State persistence errors."""
    pass


class StateCorruptedError(StateError):
    """State file corrupted or invalid JSON."""
    pass


class StateSaveFailedError(StateError):
    """Failed to save state to disk."""
    pass


class StateLoadFailedError(StateError):
    """Failed to load state from disk."""
    pass
```

**What to avoid:**
- Don't create too many specific exceptions (only add when needed for different handling)
- Don't inherit from BaseException (use Exception)
- Don't create exception hierarchies more than 3 levels deep
- Don't make exceptions do work (keep them simple data containers)

**Why these choices:**
- TradingBotError as root: Allows catching all bot-specific errors while letting system errors propagate
- 5 domain categories: Matches the major subsystems (config, API, risk, agents, state)
- Specific exceptions: Each represents a different recovery strategy or error handling path
- Docstrings: Clear documentation of when each exception is raised
  </action>
  <verify>
1. File created: `trading/exceptions.py` exists
2. Import works: `python -c "from trading.exceptions import TradingBotError; print('OK')"`
3. Hierarchy correct: All exceptions inherit from TradingBotError
4. No syntax errors: `python -m py_compile trading/exceptions.py` succeeds
  </verify>
  <done>
- Custom exception hierarchy created with 5 categories
- TradingBotError root exception for all bot errors
- 19 specific exception types covering all error scenarios
- Clear docstrings documenting when each is raised
  </done>
</task>

<task type="auto">
  <name>Task 2: Create structured logging configuration</name>
  <files>trading/logging_config.py (new)</files>
  <action>
Create structured logging configuration with JSON output and context support.

**1. Create `trading/logging_config.py`:**
```python
"""
Structured logging configuration for LLM-TradeBot.

Provides JSON-formatted logs with contextual information for production observability.
"""

import logging
import sys
from pythonjsonlogger import jsonlogger


def setup_logging(level: str = "INFO", use_json: bool = True) -> logging.Logger:
    """
    Configure structured logging for the trading bot.

    Args:
        level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        use_json: If True, output JSON format; if False, use standard text format

    Returns:
        Configured root logger

    Example:
        >>> logger = setup_logging(level="INFO", use_json=True)
        >>> logger.info("trade_executed", extra={"symbol": "BTC/USDT", "side": "buy"})
    """
    # Get root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, level.upper()))

    # Remove existing handlers to avoid duplicates
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    # Create console handler (stdout for container compatibility)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(getattr(logging, level.upper()))

    # Configure formatter
    if use_json:
        # JSON formatter for production
        json_formatter = jsonlogger.JsonFormatter(
            fmt="%(asctime)s %(levelname)s %(name)s %(message)s",
            datefmt="%Y-%m-%dT%H:%M:%S",
            rename_fields={
                "asctime": "timestamp",
                "levelname": "level",
                "name": "logger",
            },
        )
        console_handler.setFormatter(json_formatter)
    else:
        # Standard formatter for development
        text_formatter = logging.Formatter(
            fmt="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S",
        )
        console_handler.setFormatter(text_formatter)

    # Add handler to root logger
    root_logger.addHandler(console_handler)

    return root_logger


def get_logger(name: str) -> logging.Logger:
    """
    Get a logger for a specific module.

    Args:
        name: Logger name (typically __name__)

    Returns:
        Logger instance

    Example:
        >>> logger = get_logger(__name__)
        >>> logger.info("agent_vote", extra={"agent": "bull", "vote": 1.0})
    """
    return logging.getLogger(name)


# Context utilities for decision tracing
class DecisionContext:
    """
    Thread-safe context for decision tracing.

    Allows adding decision_id to all logs within a trading loop.
    """

    _context = {}

    @classmethod
    def set_decision_id(cls, decision_id: str):
        """Set decision ID for current context."""
        cls._context["decision_id"] = decision_id

    @classmethod
    def get_decision_id(cls) -> str | None:
        """Get current decision ID."""
        return cls._context.get("decision_id")

    @classmethod
    def clear(cls):
        """Clear context."""
        cls._context.clear()

    @classmethod
    def get_extra(cls) -> dict:
        """Get extra dict with decision_id for logging."""
        if decision_id := cls.get_decision_id():
            return {"decision_id": decision_id}
        return {}
```

**What to avoid:**
- Don't configure logging multiple times (check for existing handlers)
- Don't log sensitive data (API keys, secrets)
- Don't use DEBUG level in production (performance impact)
- Don't hardcode log file paths (use stdout for containers)

**Why these choices:**
- python-json-logger: Simple, standard library compatible, no heavyweight dependencies
- stdout logging: Container/cloud-native pattern, let orchestration handle log collection
- DecisionContext: Thread-safe way to add decision_id to all related logs
- Dual format: JSON for prod (machine-readable), text for dev (human-readable)
  </action>
  <verify>
1. File created: `trading/logging_config.py` exists
2. Import works: `python -c "from trading.logging_config import setup_logging; print('OK')"`
3. JSON logging works: Test with sample log message
4. No syntax errors: `python -m py_compile trading/logging_config.py` succeeds
  </verify>
  <done>
- Structured logging configuration created
- JSON formatter for production observability
- DecisionContext for correlation tracking
- Dual format support (JSON prod, text dev)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] trading/exceptions.py created with 19 exception types
- [ ] All exceptions inherit from TradingBotError
- [ ] trading/logging_config.py created with JSON support
- [ ] setup_logging() and get_logger() functions implemented
- [ ] DecisionContext class for decision tracing
- [ ] Both files have no syntax errors
- [ ] Imports work correctly
</verification>

<success_criteria>

- Both tasks completed successfully
- Exception hierarchy established for entire codebase
- Structured logging foundation in place
- Ready for Task 2 (migrate print() statements)
- Ready for Task 3 (replace generic exceptions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-decision-transparency-error-handling/04-01-SUMMARY.md`:

# Phase 4 Plan 1: Exception & Logging Foundation Summary

**[One-liner describing what shipped]**

## Accomplishments

- Created comprehensive exception hierarchy with 19 exception types
- Created structured logging configuration with JSON support
- [Additional accomplishments]

## Files Created/Modified

- `trading/exceptions.py` (new) - Custom exception hierarchy with TradingBotError root
- `trading/logging_config.py` (new) - Structured logging with JSON formatter and DecisionContext

## Decisions Made

- TradingBotError as root exception (allows catching all bot errors)
- 5 domain categories: Configuration, API, Risk, Agent, State
- python-json-logger for JSON output (simple, standard library compatible)
- stdout logging for cloud/container compatibility
- DecisionContext for decision correlation
- [Other decisions]

## Deviations from Plan

[Document any deviations using deviation rules, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Verification Results

[Results of verification checklist]

## Next Step

**Ready for Plan 04-02**: Migrate print() statements to structured logging
</output>

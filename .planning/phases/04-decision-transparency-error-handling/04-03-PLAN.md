---
phase: 04-decision-transparency-error-handling
plan: 03
type: execute
---

<objective>
Replace generic exception handling with specific exception types.

Purpose: Eliminate 50+ generic `except Exception` catches, replacing them with specific exception types that enable proper error recovery and debugging.
Output: Targeted exception handling throughout codebase, improved error recovery, better error diagnostics.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-decision-transparency-error-handling/DISCOVERY.md
@.planning/phases/04-decision-transparency-error-handling/04-01-SUMMARY.md
@.planning/phases/04-decision-transparency-error-handling/04-02-SUMMARY.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/ARCHITECTURE.md

**Codebase constraints:**
- Python 3.7+ with asyncio
- 8-agent async pipeline with error recovery
- CCXT exchange API (raises various exceptions)
- Multi-provider abstraction

**From codebase analysis (CONCERNS.md):**
- **Current issue**: 50+ generic `except Exception as e:` catches
- **Files affected**: `trading/cli.py:62,108,126,156,177,217,268`, `trading/manager.py:91,235,271,297`, most other files
- **Impact**: Masks specific errors, makes debugging harder, prevents proper recovery

**From DISCOVERY.md:**
- Exception replacement strategy: Identify specific exception types for each catch block
- Determine recovery strategy: re-raise, return default, skip operation, or notify user
- Use new exception hierarchy: TradingBotError, APIError, RiskViolationError, etc.
- Keep `except Exception` only for truly unexpected errors (with exc_info=True logging)

**Prior work:**
- Plan 04-01 completed - Exception hierarchy created in trading/exceptions.py
- Plan 04-02 completed - Logging infrastructure and timeouts in place

**Why this matters:**
Generic exception handling catches everything (including bugs) and makes it impossible to recover gracefully. Specific exceptions enable targeted recovery: retry on RateLimitExceededError, skip on InsufficientBalanceError, re-raise on StateCorruptedError.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace generic exceptions in agents</name>
  <files>trading/agents/*.py (all 8 agents)</files>
  <action>
Replace generic `except Exception` with specific exception types in all agent files.

**Pattern to follow:**

**1. Identify what can go wrong in each try block:**
- API failures → ExchangeConnectionError, RateLimitExceededError
- Missing data → InvalidIndicatorDataError, InsufficientMarketDataError
- Invalid inputs → InvalidConfigValueError
- Timeouts → AgentTimeoutError
- ML failures → ModelPredictionError

**2. Example migration in DataSyncAgent:**
```python
# ❌ Before (generic catch)
try:
    ohlcv = await self.exchange.fetch_ohlcv(symbol, "5m")
except Exception as e:
    logger.error(f"Failed to fetch OHLCV: {e}")
    return None

# ✅ After (specific catches)
from trading.exceptions import (
    ExchangeConnectionError,
    RateLimitExceededError,
    InvalidSymbolError,
    AgentTimeoutError,
    TradingBotError,
)

try:
    ohlcv = await self.exchange.fetch_ohlcv(symbol, "5m")
except asyncio.TimeoutError:
    # Timeout handled by decorator, convert to our exception
    raise AgentTimeoutError(f"Timeout fetching {symbol} OHLCV")
except ccxt.NetworkError as e:
    # Network errors - retriable
    self.logger.error(
        "exchange_network_error",
        extra={"symbol": symbol, "error": str(e)},
    )
    raise ExchangeConnectionError(f"Network error fetching {symbol}: {e}")
except ccxt.RateLimitExceeded as e:
    # Rate limit - should back off
    self.logger.warning(
        "rate_limit_exceeded",
        extra={"symbol": symbol, "retry_after": getattr(e, "retry_after", None)},
    )
    raise RateLimitExceededError(f"Rate limit exceeded for {symbol}")
except ccxt.BadSymbol as e:
    # Invalid symbol - don't retry
    self.logger.error(
        "invalid_symbol",
        extra={"symbol": symbol},
    )
    raise InvalidSymbolError(f"Symbol {symbol} not supported: {e}")
except TradingBotError:
    # Our own exceptions - re-raise
    raise
except Exception as e:
    # Truly unexpected errors - log with full traceback
    self.logger.critical(
        "unexpected_error",
        extra={"symbol": symbol, "error": str(e)},
        exc_info=True,
    )
    raise
```

**3. Example migration in QuantAnalystAgent:**
```python
# ❌ Before
try:
    rsi = talib.RSI(closes, timeperiod=14)
except Exception as e:
    logger.error(f"RSI calculation failed: {e}")
    return {"rsi": {"value": 50}}  # Neutral fallback

# ✅ After
from trading.exceptions import InvalidIndicatorDataError, InsufficientMarketDataError

try:
    if len(closes) < 14:
        raise InsufficientMarketDataError(f"Need 14+ candles for RSI, got {len(closes)}")
    if not all(isinstance(c, (int, float)) for c in closes):
        raise InvalidIndicatorDataError("Close prices contain non-numeric values")

    rsi = talib.RSI(closes, timeperiod=14)

    if rsi is None or len(rsi) == 0:
        raise InvalidIndicatorDataError("RSI calculation returned empty result")

except InsufficientMarketDataError as e:
    self.logger.warning(
        "insufficient_market_data",
        extra={"required": 14, "got": len(closes)},
    )
    # Return neutral signal instead of crashing
    return {"rsi": {"value": 50, "oversold": False, "overbought": False}}
except InvalidIndicatorDataError as e:
    self.logger.error("invalid_indicator_data", extra={"error": str(e)})
    raise  # Re-raise - this is a bug
except TradingBotError:
    raise
except Exception as e:
    self.logger.critical("unexpected_indicator_error", extra={"error": str(e)}, exc_info=True)
    raise
```

**4. Example migration in RiskAuditAgent:**
```python
# ❌ Before
try:
    if position_size > max_position:
        return (False, "Position too large")
except Exception as e:
    logger.error(f"Risk check failed: {e}")
    return (True, None)  # Dangerous: allow trade on error

# ✅ After
from trading.exceptions import (
    PositionLimitExceededError,
    InsufficientBalanceError,
    DailyDrawdownExceededError,
    CircuitBreakerTrippedError,
)

try:
    # Position size check
    if position_size > self.config.max_position_size_usd:
        raise PositionLimitExceededError(
            f"Position ${position_size:.2f} exceeds max ${self.config.max_position_size_usd:.2f}"
        )

    # Balance check
    if position_size > available_balance:
        raise InsufficientBalanceError(
            f"Position ${position_size:.2f} exceeds balance ${available_balance:.2f}"
        )

    # Circuit breaker check
    if state.circuit_breaker_active:
        raise CircuitBreakerTrippedError("Circuit breaker active due to excessive losses")

    # All checks passed
    return (True, None)

except (PositionLimitExceededError, InsufficientBalanceError, CircuitBreakerTrippedError) as e:
    # Risk violations - log and veto trade
    self.logger.warning(
        "risk_veto",
        extra={
            "reason": type(e).__name__,
            "message": str(e),
        },
    )
    return (False, str(e))
except TradingBotError:
    raise
except Exception as e:
    # Unexpected errors - FAIL SAFE (reject trade)
    self.logger.critical(
        "risk_check_error",
        extra={"error": str(e)},
        exc_info=True,
    )
    # Return False to reject trade (fail-safe behavior)
    return (False, f"Risk check failed: {e}")
```

**Agent-specific exception mappings:**
- **DataSyncAgent**: ExchangeConnectionError, RateLimitExceededError, InvalidSymbolError, AgentTimeoutError
- **QuantAnalystAgent**: InvalidIndicatorDataError, InsufficientMarketDataError
- **PredictAgent**: ModelPredictionError, InvalidIndicatorDataError
- **BullAgent/BearAgent**: InvalidIndicatorDataError
- **DecisionCoreAgent**: (rarely fails, mostly ValueError for bad inputs)
- **RiskAuditAgent**: PositionLimitExceededError, InsufficientBalanceError, CircuitBreakerTrippedError, DailyDrawdownExceededError
- **ExecutionAgent**: OrderRejectedError, InsufficientBalanceError, ExchangeConnectionError

**What to avoid:**
- Don't catch Exception and continue silently (makes debugging impossible)
- Don't catch exceptions you can't handle (let them propagate)
- Don't use bare `except:` (catches even KeyboardInterrupt)
- Don't catch exceptions for control flow (use if/else instead)

**Why these choices:**
- Specific exceptions: Each represents a different failure mode requiring different handling
- Re-raise vs. return: Re-raise bugs, return defaults for expected failures
- Fail-safe in RiskAudit: Always reject trade on unexpected error (prevents losses)
- Critical logging: Unexpected errors logged with full traceback for debugging
  </action>
  <verify>
1. Generic catches reduced: `grep -r "except Exception" trading/agents/*.py | wc -l` shows significant reduction
2. Specific exceptions used: `grep -r "except.*Error" trading/agents/*.py` shows custom exceptions
3. All agents import from trading.exceptions: `grep -r "from trading.exceptions import" trading/agents/*.py`
4. No bare except: `grep -r "except:" trading/agents/*.py` returns empty
5. No syntax errors: `python -m py_compile trading/agents/*.py` succeeds
  </verify>
  <done>
- Generic exception catches replaced in all 8 agents
- Specific exception types for each failure mode
- Proper error recovery strategies (re-raise, default, veto)
- Fail-safe behavior in RiskAudit
- Critical logging for unexpected errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace generic exceptions in manager, CLI, and state</name>
  <files>trading/manager.py, trading/cli.py, trading/state.py, trading/providers/*.py</files>
  <action>
Replace remaining generic exception catches in core infrastructure files.

**1. Update `trading/manager.py`:**
```python
# ❌ Before (generic catch in trading loop)
try:
    decision = await self.decision_core.execute(context)
except Exception as e:
    logger.error(f"Decision failed: {e}")
    continue

# ✅ After (specific catches)
from trading.exceptions import (
    AgentError,
    APIError,
    RiskViolationError,
    StateError,
    TradingBotError,
)

try:
    decision = await self.decision_core.execute(context)
except AgentError as e:
    # Agent failures - log and skip this iteration
    self.logger.error(
        "agent_execution_failed",
        extra={"agent": "decision_core", "error": str(e)},
    )
    continue  # Skip this trading iteration
except APIError as e:
    # API errors - log and retry next iteration
    self.logger.warning(
        "api_error",
        extra={"error": str(e)},
    )
    await asyncio.sleep(5)  # Brief pause before retry
    continue
except RiskViolationError as e:
    # Risk veto - log and continue (trade rejected)
    self.logger.info(
        "risk_veto",
        extra={"reason": str(e)},
    )
    continue
except StateError as e:
    # State errors - critical, might need to stop
    self.logger.critical(
        "state_error",
        extra={"error": str(e)},
        exc_info=True,
    )
    # Try to save current state before continuing
    try:
        await self.state.save()
    except Exception:
        pass  # Best effort
    continue
except TradingBotError as e:
    # Known errors - log and continue
    self.logger.error(
        "trading_error",
        extra={"error_type": type(e).__name__, "message": str(e)},
    )
    continue
except Exception as e:
    # Unexpected errors - log with traceback, continue with caution
    self.logger.critical(
        "unexpected_trading_error",
        extra={"error": str(e)},
        exc_info=True,
    )
    # Continue after brief pause (might be transient)
    await asyncio.sleep(10)
    continue
```

**2. Update `trading/cli.py` command handlers:**
```python
# ❌ Before (identical try-except in each command)
try:
    result = await manager.get_status()
    print(json.dumps(result))
except Exception as e:
    print(json.dumps({"error": str(e)}))

# ✅ After (specific catches)
from trading.exceptions import ConfigurationError, StateError, TradingBotError

try:
    result = await manager.get_status()
    self.logger.info("cli_command", extra={"command": "status", "success": True})
    print(json.dumps(result))
except ConfigurationError as e:
    self.logger.error("configuration_error", extra={"error": str(e)})
    print(json.dumps({"error": f"Configuration error: {e}"}))
    sys.exit(1)  # Fatal error
except StateError as e:
    self.logger.error("state_error", extra={"error": str(e)})
    print(json.dumps({"error": f"State error: {e}"}))
    sys.exit(1)  # Fatal error
except TradingBotError as e:
    self.logger.error("command_failed", extra={"command": "status", "error": str(e)})
    print(json.dumps({"error": str(e)}))
    sys.exit(1)
except Exception as e:
    self.logger.critical("unexpected_cli_error", extra={"error": str(e)}, exc_info=True)
    print(json.dumps({"error": f"Unexpected error: {e}"}))
    sys.exit(1)
```

**3. Update `trading/state.py`:**
```python
# ❌ Before
try:
    with open(self.state_file, "w") as f:
        json.dump(state_dict, f)
except Exception as e:
    logger.error(f"Failed to save state: {e}")

# ✅ After
import tempfile
import os
from trading.exceptions import StateSaveFailedError, StateCorruptedError

def save(self):
    """Save state atomically to prevent corruption."""
    try:
        state_dict = self.to_dict()

        # Atomic write pattern: temp file + rename
        fd, temp_path = tempfile.mkstemp(
            dir=os.path.dirname(self.state_file),
            prefix=".trading_state_",
            suffix=".tmp",
        )
        try:
            with os.fdopen(fd, "w") as f:
                json.dump(state_dict, f, indent=2)

            # Atomic rename
            os.replace(temp_path, self.state_file)

            self.logger.debug(
                "state_saved",
                extra={"file": self.state_file, "size_bytes": os.path.getsize(self.state_file)},
            )
        except Exception as e:
            # Clean up temp file on failure
            try:
                os.unlink(temp_path)
            except Exception:
                pass
            raise

    except (IOError, OSError) as e:
        self.logger.error("state_save_io_error", extra={"error": str(e)}, exc_info=True)
        raise StateSaveFailedError(f"Failed to save state: {e}")
    except Exception as e:
        self.logger.critical("state_save_unexpected_error", extra={"error": str(e)}, exc_info=True)
        raise StateSaveFailedError(f"Unexpected error saving state: {e}")


def load(self):
    """Load state from file, handling corruption gracefully."""
    try:
        with open(self.state_file, "r") as f:
            data = json.load(f)

        # Validate required fields
        required = ["positions", "balance_usd", "total_pnl"]
        missing = [field for field in required if field not in data]
        if missing:
            raise StateCorruptedError(f"Missing required fields: {missing}")

        self.logger.debug("state_loaded", extra={"file": self.state_file})
        return TradingState.from_dict(data)

    except FileNotFoundError:
        self.logger.info("state_not_found", extra={"file": self.state_file})
        return TradingState()  # New state
    except json.JSONDecodeError as e:
        self.logger.error(
            "state_corrupted_json",
            extra={"file": self.state_file, "error": str(e)},
        )
        raise StateCorruptedError(f"State file corrupted (invalid JSON): {e}")
    except StateCorruptedError:
        raise  # Re-raise our exception
    except Exception as e:
        self.logger.critical(
            "state_load_unexpected_error",
            extra={"error": str(e)},
            exc_info=True,
        )
        raise StateLoadFailedError(f"Unexpected error loading state: {e}")
```

**What to avoid:**
- Don't catch IOError and OSError separately (use tuple)
- Don't ignore state save failures (raise exception)
- Don't continue trading if state can't be saved (data loss risk)
- Don't retry CLI commands automatically (user should decide)

**Why these choices:**
- Manager loop resilience: Continue on most errors (system keeps running)
- CLI fail-fast: Exit on errors (user invoked, should see failures)
- State atomic writes: Temp file + rename prevents corruption
- State corruption handling: Graceful fallback to new state vs. crash
  </action>
  <verify>
1. Generic catches reduced: `grep -r "except Exception" trading/ --include="*.py" | wc -l` shows significant reduction
2. State uses atomic writes: Check trading/state.py for tempfile.mkstemp + os.replace
3. Manager has specific catches: Check trading/manager.py for AgentError, APIError, RiskViolationError
4. CLI has specific catches: Check trading/cli.py for ConfigurationError, StateError
5. All files import trading.exceptions: `grep -r "from trading.exceptions import" trading/*.py`
6. No syntax errors: `python -m py_compile trading/*.py` succeeds
  </verify>
  <done>
- Generic exception catches replaced in manager, CLI, state
- Atomic state writes prevent corruption
- Specific error recovery strategies per file
- Manager continues on most errors (resilience)
- CLI exits on errors (fail-fast for user)
- State handles corruption gracefully
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Generic `except Exception` significantly reduced (50+ → <10)
- [ ] All agents use specific exception types
- [ ] Manager has targeted error recovery
- [ ] CLI has fail-fast error handling
- [ ] State uses atomic writes with error handling
- [ ] All files import from trading.exceptions
- [ ] No bare `except:` clauses
- [ ] Unexpected errors logged with exc_info=True
</verification>

<success_criteria>

- Both tasks completed successfully
- Generic exception handling eliminated
- Specific exception types throughout codebase
- Targeted error recovery strategies
- Improved error diagnostics and debugging
- Phase 4 (Decision Transparency & Error Handling) COMPLETE
- Ready for production deployment
</success_criteria>

<output>
After completion, create `.planning/phases/04-decision-transparency-error-handling/04-03-SUMMARY.md`:

# Phase 4 Plan 3: Exception Handling Migration Summary

**[One-liner describing what shipped]**

## Accomplishments

- Replaced 50+ generic exception catches with specific types
- Implemented targeted error recovery strategies
- Added atomic state writes to prevent corruption
- [Additional accomplishments]

## Files Created/Modified

- `trading/agents/*.py` (8 files) - Specific exception handling per agent
- `trading/manager.py` - Resilient error recovery in trading loop
- `trading/cli.py` - Fail-fast error handling for user commands
- `trading/state.py` - Atomic writes with corruption handling

## Decisions Made

- Manager continues on most errors (system resilience)
- CLI exits on errors (fail-fast for user)
- RiskAudit rejects trades on unexpected errors (fail-safe)
- State load falls back to new state on corruption (graceful degradation)
- Unexpected errors logged with exc_info=True (full traceback)
- [Other decisions]

## Deviations from Plan

[Document any deviations using deviation rules, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Verification Results

[Results of verification checklist]

## Next Step

**Phase 4 Complete!** All transparency and error handling improvements finished.

Ready for production deployment with:
- ✅ Custom exception hierarchy (19 exception types)
- ✅ Structured JSON logging (79 print() → logger)
- ✅ Async timeouts (all external operations)
- ✅ Decision tracing (correlation via decision_id)
- ✅ Specific error handling (50+ → <10 generic catches)
</output>

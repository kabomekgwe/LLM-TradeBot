# Phase 10 Plan 1: Real-Time Monitoring Infrastructure

**Phase**: 10-real-time-monitoring-infrastructure
**Plan**: 10-01
**Created**: 2025-12-27
**Estimated LOC**: ~1,500 lines (3 tasks)

---

## Context

**What we're building**: Real-time monitoring dashboard with multi-channel alerts for comprehensive trading system visibility.

**Why this matters**: Production trading requires live visibility into trading activity, risk metrics, and system health. Missing critical alerts (circuit breaker trips, drawdown limits) could lead to undetected failures.

**What already exists** (from discovery):
- ✅ FastAPI dashboard server with WebSocket support (`trading/web/server.py`)
- ✅ HTML/CSS/JS frontend dashboard (`trading/web/static/`)
- ✅ Multi-channel notification system (`trading/notifications/` - Slack, Email, Telegram)
- ✅ Metrics calculation functions (Sharpe, drawdown, win rate in `trading/memory/trade_history.py`)
- ✅ Safety controls from Phase 9 (kill switch, circuit breaker, position limits)

**What we need to build**:
1. Real-time metrics integration - stream live Sharpe/drawdown/win rate to dashboard
2. System health monitoring - display safety controls status (kill switch, circuit breaker, positions)
3. Multi-channel alert triggers - connect notifications to critical events (threshold breaches, safety trips)

**Dependencies**: Phase 9 (safety controls - kill switch, circuit breaker, position limits)

---

## Success Criteria

### Functional Requirements
- [ ] Dashboard displays real-time metrics (Sharpe ratio, drawdown, win rate, P&L) updated after each trade
- [ ] Dashboard shows system health status (kill switch state, circuit breaker state, position utilization, API status)
- [ ] Alerts fire to Slack/Email/Telegram when thresholds breached (drawdown limits, circuit breaker trips, kill switch activation)
- [ ] WebSocket updates deliver live data to dashboard without polling
- [ ] All three monitoring aspects work correctly (trading activity, risk metrics, system health)

### Quality Requirements
- [ ] All new modules compile without errors
- [ ] Real-time calculations are accurate (Sharpe, drawdown, win rate match expected formulas)
- [ ] Alert delivery is reliable (no missed critical alerts)
- [ ] Dashboard updates reflect state changes within 1 second

### Integration Requirements
- [ ] Metrics calculator integrates with main trading loop (updates after each trade)
- [ ] Notification manager triggers alerts on safety control events
- [ ] Dashboard frontend consumes WebSocket updates correctly
- [ ] Configuration supports environment-based webhook URLs (Slack, Email, Telegram)

---

## Tasks

### Task 1: Real-Time Performance Metrics Integration

**Objective**: Stream live trading performance metrics to dashboard with accurate real-time calculations.

**What to build**:

1. **Create Real-Time Metrics Calculator** (`trading/monitoring/metrics_tracker.py`):
   - `MetricsTracker` class that maintains rolling window of trades
   - Calculate real-time Sharpe ratio (annualized returns / std dev)
   - Calculate current drawdown (peak equity - current equity) / peak equity
   - Calculate win rate (winning trades / total trades)
   - Calculate total P&L and daily P&L
   - Update metrics after each trade execution
   - Use existing formulas from `trading/memory/trade_history.py` and `trading/ml/evaluation/metrics.py`

2. **Add WebSocket Broadcasting for Metrics** (modify `trading/web/server.py`):
   - Create `/api/v1/metrics/realtime` endpoint for current metrics snapshot
   - Add `broadcast_metrics_update()` method (already exists - verify it's being called)
   - Broadcast metrics to all connected WebSocket clients after each calculation

3. **Integrate into Main Trading Loop** (modify `trading/manager.py`):
   - Initialize `MetricsTracker` in `TradingManager.__init__()`
   - Call `metrics_tracker.update(trade)` after each trade execution
   - Broadcast metrics update via dashboard server after calculation
   - Ensure metrics update happens AFTER safety checkpoints

4. **Update Dashboard Frontend** (modify `trading/web/static/app.js`):
   - Add WebSocket listener for `metrics_update` message type
   - Update metrics cards (Sharpe, drawdown, win rate, P&L) on each message
   - Add color coding (green for positive, red for negative, yellow for warnings)
   - Format numbers correctly (2 decimal places for Sharpe, percentage for drawdown/win rate, currency for P&L)

**Files to create**:
- `trading/monitoring/__init__.py` - Module exports
- `trading/monitoring/metrics_tracker.py` - Real-time metrics calculator

**Files to modify**:
- `trading/web/server.py` - Add real-time metrics endpoint
- `trading/manager.py` - Integrate metrics tracker
- `trading/web/static/app.js` - Handle metrics WebSocket updates

**Estimated LOC**: ~600 lines

---

### Task 2: System Health Monitoring Dashboard

**Objective**: Display real-time safety controls status and system health on dashboard.

**What to build**:

1. **Create System Health Status Module** (`trading/monitoring/system_health.py`):
   - `SystemHealthMonitor` class that aggregates safety control states
   - Methods to check kill switch status, circuit breaker status, position utilization
   - Calculate API connection status (ping exchange API)
   - Aggregate into single health status object
   - Health levels: HEALTHY, DEGRADED, CRITICAL

2. **Add Health Status API Endpoints** (modify `trading/web/server.py`):
   - `GET /api/v1/health/status` - Current system health snapshot
   - `GET /api/v1/health/safety` - Safety controls detailed status (kill switch, circuit breaker, position limits)
   - Add WebSocket broadcasting for health status changes
   - Broadcast when kill switch activates, circuit breaker trips, or position limits hit

3. **Extend Dashboard Frontend** (modify `trading/web/static/index.html` and `app.js`):
   - Add "System Health" section below metrics cards
   - Display kill switch status (ACTIVE/INACTIVE with red/green indicator)
   - Display circuit breaker status (OPEN/CLOSED with reason if open)
   - Display position utilization (current positions / max positions as progress bar)
   - Display API connection status (CONNECTED/DISCONNECTED with latency)
   - Update health section via WebSocket on state changes

4. **Integrate Health Monitoring** (modify `trading/manager.py`):
   - Initialize `SystemHealthMonitor` in `TradingManager.__init__()`
   - Broadcast health status changes when safety controls trigger
   - Poll health status every 30 seconds (API ping check)

**Files to create**:
- `trading/monitoring/system_health.py` - System health aggregator

**Files to modify**:
- `trading/web/server.py` - Add health status endpoints
- `trading/web/static/index.html` - Add system health section HTML
- `trading/web/static/app.js` - Handle health WebSocket updates
- `trading/manager.py` - Integrate health monitor

**Estimated LOC**: ~400 lines

---

### Task 3: Multi-Channel Alert Integration

**Objective**: Trigger Slack/Email/Telegram alerts when critical thresholds breached or safety controls activate.

**What to build**:

1. **Create Alert Trigger Configuration** (`trading/monitoring/alert_triggers.py`):
   - `AlertTrigger` dataclass defining trigger conditions
   - Predefined triggers:
     - Drawdown exceeds daily limit (5%)
     - Drawdown exceeds weekly limit (10%)
     - Drawdown exceeds total limit (20%)
     - Circuit breaker trips (any threshold)
     - Kill switch activated
     - Consecutive losses exceed limit (10 trades)
     - API errors exceed rate (3/minute)
   - Methods to check if current state matches trigger conditions
   - Debouncing logic to prevent alert spam (max 1 alert per trigger per 5 minutes)

2. **Integrate Alert Manager** (create `trading/monitoring/alert_manager.py`):
   - `AlertManager` class that coordinates trigger checks and notification delivery
   - Check triggers after each trade, safety event, and health status change
   - Send notifications via `trading/notifications/manager.py` to all enabled channels
   - Log all sent alerts with timestamp and trigger reason
   - Support alert configuration from environment (enable/disable channels, webhook URLs)

3. **Configure Notification Webhooks** (modify `trading/config.py`):
   - Add configuration fields for Slack webhook URL, Email SMTP settings, Telegram bot token
   - Load from environment variables (`SLACK_WEBHOOK_URL`, `EMAIL_SMTP_HOST`, etc.)
   - Add enable/disable flags for each channel (`ALERTS_SLACK_ENABLED`, etc.)
   - Default to all channels disabled for safety (require explicit opt-in)

4. **Integrate into Trading Loop** (modify `trading/manager.py`):
   - Initialize `AlertManager` in `TradingManager.__init__()`
   - Check alert triggers after:
     - Each trade execution
     - Kill switch activation
     - Circuit breaker trip
     - Position limit rejection
   - Pass current state (metrics, safety status) to trigger checker

5. **Add Alert Testing Endpoint** (modify `trading/web/server.py`):
   - `POST /api/v1/alerts/test` - Send test alert to verify channel configuration
   - Accepts channel parameter (slack, email, telegram, or "all")
   - Returns success/failure status for each channel
   - Requires HMAC authentication (same as kill switch)

**Files to create**:
- `trading/monitoring/alert_triggers.py` - Alert trigger definitions and checking logic
- `trading/monitoring/alert_manager.py` - Alert coordination and delivery

**Files to modify**:
- `trading/config.py` - Add notification webhook configuration
- `trading/manager.py` - Integrate alert manager
- `trading/web/server.py` - Add alert testing endpoint

**Estimated LOC**: ~500 lines

---

## Implementation Notes

### Integration Points

**Main Trading Loop Integration** (`trading/manager.py`):
```python
class TradingManager:
    def __init__(self, ...):
        # Existing safety controls (Phase 9)
        self.kill_switch = KillSwitch(...)
        self.circuit_breaker = CircuitBreaker(...)
        self.position_limits = PositionLimitEnforcer(...)

        # NEW: Monitoring infrastructure (Phase 10)
        self.metrics_tracker = MetricsTracker(...)
        self.health_monitor = SystemHealthMonitor(
            kill_switch=self.kill_switch,
            circuit_breaker=self.circuit_breaker,
            position_limits=self.position_limits
        )
        self.alert_manager = AlertManager(
            notification_manager=self.notification_manager,
            config=self.config
        )

    async def run_trading_loop(self):
        # CHECKPOINT 1: Kill switch check (Phase 9)
        if self.kill_switch.is_active():
            await self.alert_manager.check_triggers(...)  # NEW
            return None

        # CHECKPOINT 2: Circuit breaker check (Phase 9)
        if self.circuit_breaker.is_open():
            await self.alert_manager.check_triggers(...)  # NEW
            return None

        # ... trading logic ...

        # CHECKPOINT 4: Update monitoring after trade (NEW)
        if trade_executed:
            self.metrics_tracker.update(trade)  # Calculate metrics
            await self.dashboard_server.broadcast_metrics_update(...)  # Stream to dashboard
            await self.alert_manager.check_triggers(...)  # Check alert conditions
```

### WebSocket Message Types

**New message types to add** (in `trading/web/websocket.py`):
- `METRICS_UPDATE` - Real-time metrics (Sharpe, drawdown, win rate, P&L)
- `HEALTH_UPDATE` - System health status change
- `ALERT_TRIGGERED` - Critical alert fired (for dashboard notification badge)

### Alert Debouncing

Prevent alert spam with 5-minute cooldown per trigger:
```python
# In AlertManager
self.last_alert_time: Dict[str, datetime] = {}  # trigger_id -> last sent time

def should_send_alert(self, trigger_id: str) -> bool:
    if trigger_id not in self.last_alert_time:
        return True
    elapsed = datetime.now() - self.last_alert_time[trigger_id]
    return elapsed.total_seconds() > 300  # 5 minutes
```

### Environment Variables

Required configuration (add to deployment docs):
```bash
# Alert Channels (all optional, default disabled)
ALERTS_SLACK_ENABLED=true
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/XXX

ALERTS_EMAIL_ENABLED=true
EMAIL_SMTP_HOST=smtp.gmail.com
EMAIL_SMTP_PORT=587
EMAIL_FROM=alerts@trading-bot.com
EMAIL_TO=trader@example.com

ALERTS_TELEGRAM_ENABLED=true
TELEGRAM_BOT_TOKEN=YOUR_BOT_TOKEN
TELEGRAM_CHAT_ID=YOUR_CHAT_ID
```

---

## Testing Strategy

### Unit Tests

**Metrics Tracker Tests** (`trading/tests/test_monitoring_metrics.py`):
- Test Sharpe ratio calculation with sample trades
- Test drawdown calculation (peak to trough)
- Test win rate calculation
- Test P&L aggregation (daily and total)
- Test metrics reset after system restart

**System Health Tests** (`trading/tests/test_monitoring_health.py`):
- Test health status aggregation (all components healthy)
- Test health degradation when circuit breaker trips
- Test critical status when kill switch active
- Test API connection check (mock exchange ping)

**Alert Trigger Tests** (`trading/tests/test_monitoring_alerts.py`):
- Test trigger condition matching (drawdown thresholds)
- Test debouncing logic (no spam within 5 minutes)
- Test alert delivery to notification manager
- Test alert configuration (enable/disable channels)

### Integration Tests

**End-to-End Monitoring Flow** (`trading/tests/test_monitoring_integration.py`):
1. Execute mock trade
2. Verify metrics update broadcasted via WebSocket
3. Verify health status reflects current state
4. Trigger drawdown threshold breach
5. Verify alert sent to all enabled channels
6. Verify dashboard receives all updates

### Manual Testing

**Dashboard Verification**:
1. Start dashboard server: `python -m trading.web.server`
2. Open browser: `http://localhost:5173`
3. Execute test trades and verify metrics update in real-time
4. Trigger circuit breaker and verify health section updates
5. Send test alert via API and verify delivery to Slack/Email/Telegram

**Alert Testing**:
```bash
# Send test alert to all channels
curl -X POST http://localhost:5173/api/v1/alerts/test \
  -H "X-HMAC-Signature: <signature>" \
  -H "Content-Type: application/json" \
  -d '{"channel": "all", "test_message": "Alert system test"}'
```

---

## Risk Mitigation

### Risk 1: Alert Spam from Rapid State Changes
- **Mitigation**: Implement 5-minute debouncing per trigger type
- **Fallback**: Add global alert rate limit (max 10 alerts per hour)

### Risk 2: WebSocket Connection Drops
- **Mitigation**: Frontend auto-reconnect with exponential backoff
- **Fallback**: Polling fallback if WebSocket fails 3 times

### Risk 3: Incorrect Metrics Calculation
- **Mitigation**: Use existing battle-tested formulas from `trade_history.py` and `ml/evaluation/metrics.py`
- **Verification**: Unit tests with known inputs/outputs for each metric

### Risk 4: Notification Delivery Failure
- **Mitigation**: Log all alert attempts with success/failure status
- **Fallback**: Retry failed alerts once after 1 minute

---

## Definition of Done

- [ ] All 3 tasks completed
- [ ] Dashboard displays real-time metrics (Sharpe, drawdown, win rate, P&L)
- [ ] Dashboard displays system health (kill switch, circuit breaker, positions, API status)
- [ ] Alerts fire to Slack/Email/Telegram on threshold breaches
- [ ] WebSocket updates deliver data to dashboard without polling
- [ ] All unit tests pass (metrics, health, alerts)
- [ ] Integration test passes (end-to-end monitoring flow)
- [ ] Manual dashboard verification completed
- [ ] Alert delivery tested for all channels
- [ ] Environment configuration documented
- [ ] Code committed with descriptive message
- [ ] SUMMARY.md created documenting accomplishments

---

**Plan ready for execution. Expected duration: ~45-60 minutes for all 3 tasks.**

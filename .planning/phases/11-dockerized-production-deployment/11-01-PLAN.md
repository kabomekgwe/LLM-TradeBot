# Phase 11 Plan 1: Dockerized Production Deployment

**Phase**: 11-dockerized-production-deployment
**Plan**: 11-01
**Created**: 2025-12-28
**Estimated LOC**: ~1,600 lines (3 tasks)

---

## Context

**What we're building**: Complete Docker-based production deployment infrastructure with containerization, health monitoring, and deployment workflow.

**Why this matters**: Production deployment requires portable, reliable containerization that can run anywhere (local dev, cloud VPS, managed services). Without proper Docker infrastructure, deployments are fragile, environment-dependent, and lack automated recovery from failures.

**What already exists** (from discovery):
- ✅ Phase 10 monitoring infrastructure (`/api/v1/health/status`, `/api/v1/health/safety`)
- ✅ Phase 9 safety controls (kill switch, circuit breaker, position limits)
- ✅ FastAPI dashboard server with WebSocket support (`trading/web/server.py`)
- ✅ CLI entry points (`trading/cli.py`, `trading/cli_deep_learning.py`)
- ✅ Complete dependency list (`requirements.txt` - PyTorch, CCXT, FastAPI, etc.)
- ✅ Environment configuration template (`.env.example`)

**What we need to build**:
1. Docker containerization - Multi-stage Dockerfile, Docker Compose orchestration, volume management
2. Health checks & auto-restart - Docker health checks, graceful shutdown, restart policies
3. Production deployment workflow - Deployment docs, environment templates, deployment scripts

**Dependencies**: Phase 10 (monitoring infrastructure provides health check endpoints)

**Scope boundaries** (from 11-CONTEXT.md):
- ✅ IN SCOPE: Docker + Docker Compose, health checks, manual deployment workflow
- ❌ OUT OF SCOPE: Centralized logging (Phase 10 monitoring sufficient), advanced CI/CD (blue-green, canary), production secrets vault (env vars acceptable)

---

## Success Criteria

### Functional Requirements
- [ ] Trading bot runs in Docker containers with all dependencies (Python 3.13, PyTorch, ML models, API keys)
- [ ] Docker Compose orchestrates multiple services (trading bot, dashboard server, optional database)
- [ ] Health checks verify API responsive, database connected, models loaded
- [ ] Containers automatically restart on crash (restart policy configured)
- [ ] Graceful shutdown closes positions safely when stopping containers
- [ ] Production deployment workflow is clear and repeatable (even if manual)

### Quality Requirements
- [ ] Dockerfile uses multi-stage build for optimized image size (<1GB final image)
- [ ] All environment variables loaded from `.env` file (no secrets in Dockerfile)
- [ ] Volumes persist data across container restarts (models, trade history, logs)
- [ ] Health checks detect failures within 30 seconds
- [ ] Containers start in <60 seconds (model loading time)

### Integration Requirements
- [ ] Docker health checks integrate with Phase 10 health endpoints (`/api/v1/health/status`)
- [ ] Dashboard accessible on host machine (port mapping configured)
- [ ] Logs visible via `docker logs` command
- [ ] Environment configuration supports local dev and production

---

## Tasks

### Task 1: Docker Containerization

**Objective**: Create production-ready Docker containers with multi-stage builds, proper dependency management, and volume persistence.

**What to build**:

1. **Create Multi-Stage Dockerfile** (`Dockerfile`):
   - **Stage 1: Builder** (compile dependencies)
     - Base: `python:3.13-slim-bookworm`
     - Install build dependencies (gcc, g++, make for TA-Lib compilation)
     - Install Python dependencies from `requirements.txt`
     - Compile TA-Lib from source (required for technical indicators)
   - **Stage 2: Runtime** (minimal production image)
     - Base: `python:3.13-slim-bookworm`
     - Copy only runtime dependencies from builder stage
     - Copy application code (`trading/` directory)
     - Set working directory to `/app`
     - Create non-root user `tradingbot` (UID 1000)
     - Switch to non-root user for security
   - **Optimizations**:
     - Use `.dockerignore` to exclude tests, docs, `.planning/`, `__pycache__`
     - Layer caching: Install dependencies before copying code
     - Target image size: <1GB (PyTorch is large, but multi-stage helps)

2. **Create Docker Compose Configuration** (`docker-compose.yml`):
   - **Service: trading-bot**
     - Build from Dockerfile
     - Command: `python -m trading.cli run`
     - Environment variables from `.env` file
     - Volumes:
       - `./models:/app/models` (persist trained models)
       - `./data:/app/data` (persist trade history, logs)
       - `./.env:/app/.env:ro` (read-only env file)
     - Restart policy: `unless-stopped`
     - Health check: `curl -f http://localhost:5173/api/v1/health/status || exit 1`
     - Depends on: `dashboard` service
   - **Service: dashboard**
     - Same image as trading-bot
     - Command: `python -m trading.web.server`
     - Port mapping: `5173:5173` (dashboard accessible on host)
     - Environment variables from `.env`
     - Volumes: same as trading-bot (shared data)
     - Restart policy: `unless-stopped`
     - Health check: `curl -f http://localhost:5173/health || exit 1`
   - **Optional Service: postgres** (for future Phase 12 trade history database)
     - Image: `postgres:16-alpine`
     - Environment: `POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD`
     - Volume: `postgres-data:/var/lib/postgresql/data`
     - Port: `5432:5432`
     - Comment out by default (not required for Phase 11)

3. **Create .dockerignore** (`.dockerignore`):
   - Exclude: `.planning/`, `tests/`, `__pycache__/`, `.pytest_cache/`, `.git/`, `*.md`, `examples/`, `.env` (will be mounted separately)
   - Include: `requirements.txt`, `trading/`, `models/` (if pre-trained models exist)

4. **Create Production Environment Template** (`.env.production.template`):
   - Copy from `.env.example`
   - Add Docker-specific variables:
     - `DASHBOARD_HOST=0.0.0.0` (bind to all interfaces for container access)
     - `DASHBOARD_PORT=5173`
     - `LOG_LEVEL=INFO` (less verbose for production)
   - Add comments explaining production vs development values
   - Note: User must copy to `.env` and fill in actual API keys

5. **Update .gitignore** (modify `.gitignore`):
   - Add Docker-related entries:
     - `*.tar` (Docker image exports)
     - `.env.production` (production secrets)
     - `models/*.pth` (large model files, download separately)
     - `data/` (runtime data directory)

**Files to create**:
- `Dockerfile` - Multi-stage build for Python + PyTorch app
- `docker-compose.yml` - Multi-container orchestration
- `.dockerignore` - Exclude unnecessary files from build context
- `.env.production.template` - Production environment template
- `scripts/docker-build.sh` - Build script with tagging
- `scripts/docker-run.sh` - Run script for local testing

**Files to modify**:
- `.gitignore` - Add Docker-related exclusions

**Estimated LOC**: ~700 lines (Dockerfile ~150, docker-compose.yml ~100, scripts ~200, templates ~250)

---

### Task 2: Health Checks & Auto-Restart

**Objective**: Implement Docker health checks, graceful shutdown handlers, and automatic crash recovery.

**What to build**:

1. **Add Docker Health Check Endpoint** (modify `trading/web/server.py`):
   - Create `GET /health` endpoint (lightweight, no authentication)
     - Check 1: FastAPI server responsive (return 200 if this endpoint runs)
     - Check 2: Kill switch not active (query KillSwitch instance if available)
     - Check 3: Circuit breaker not open (query CircuitBreaker instance if available)
     - Return `{"status": "healthy", "timestamp": "<ISO8601>"}` if all pass
     - Return 503 Service Unavailable if any check fails
   - This is simpler than `/api/v1/health/status` (no detailed metrics, just binary healthy/unhealthy)
   - Purpose: Docker HEALTHCHECK needs fast, simple check (runs every 30s)

2. **Implement Graceful Shutdown Handler** (create `trading/utils/shutdown.py`):
   - `GracefulShutdownHandler` class:
     - Register signal handlers for SIGTERM, SIGINT (Docker stop sends SIGTERM)
     - On signal received:
       - Log shutdown initiated
       - Cancel all pending orders via exchange API
       - Close all open positions (market orders for immediate exit)
       - Save current state to disk (`TradingState.save()`)
       - Broadcast shutdown notification via alerts (Slack/Email/Telegram)
       - Wait for operations to complete (max 30 seconds timeout)
       - Exit gracefully with status 0
   - Integration point: Initialize in `TradingManager.__init__()`
   - Example:
     ```python
     shutdown_handler = GracefulShutdownHandler(
         manager=self,
         timeout=30
     )
     shutdown_handler.register()
     ```

3. **Update Docker Compose Health Checks** (modify `docker-compose.yml`):
   - **trading-bot service**:
     ```yaml
     healthcheck:
       test: ["CMD", "curl", "-f", "http://dashboard:5173/health"]
       interval: 30s
       timeout: 10s
       retries: 3
       start_period: 60s  # Allow 60s for model loading
     ```
   - **dashboard service**:
     ```yaml
     healthcheck:
       test: ["CMD", "curl", "-f", "http://localhost:5173/health"]
       interval: 30s
       timeout: 10s
       retries: 3
       start_period: 30s
     ```
   - Restart policies already set to `unless-stopped` in Task 1

4. **Add Health Check Dependencies to Dockerfile** (modify `Dockerfile`):
   - Install `curl` in runtime stage (needed for HEALTHCHECK command):
     ```dockerfile
     RUN apt-get update && apt-get install -y --no-install-recommends \
         curl \
         && rm -rf /var/lib/apt/lists/*
     ```

5. **Create Health Check Testing Script** (`scripts/test-health-checks.sh`):
   - Start containers: `docker-compose up -d`
   - Wait for healthy status: `docker-compose ps` (check HEALTH column)
   - Simulate crash: `docker-compose kill trading-bot` (send SIGKILL)
   - Verify auto-restart: Wait 10s, check container restarted
   - Verify graceful shutdown: `docker-compose stop` (sends SIGTERM)
   - Check logs for graceful shutdown messages

6. **Integrate into Main Trading Loop** (modify `trading/manager.py`):
   - Initialize `GracefulShutdownHandler` in `__init__`
   - Ensure shutdown handler has access to:
     - Exchange provider (to cancel orders/close positions)
     - TradingState (to save state)
     - AlertManager (to send shutdown notifications)

**Files to create**:
- `trading/utils/shutdown.py` - Graceful shutdown handler (~350 LOC)
- `scripts/test-health-checks.sh` - Health check testing script (~100 LOC)

**Files to modify**:
- `trading/web/server.py` - Add `/health` endpoint (~50 LOC)
- `trading/manager.py` - Integrate shutdown handler (~30 LOC)
- `Dockerfile` - Install curl for health checks (~10 LOC)
- `docker-compose.yml` - Add health check configurations (~40 LOC)

**Estimated LOC**: ~580 lines

---

### Task 3: Production Deployment Workflow

**Objective**: Create clear, repeatable deployment workflow with documentation, scripts, and environment templates.

**What to build**:

1. **Create Deployment Documentation** (`docs/DEPLOYMENT.md`):
   - **Prerequisites**:
     - Docker 24+ installed
     - Docker Compose 2.20+ installed
     - API keys for exchange (Binance, Kraken, etc.)
     - Server with 4GB+ RAM, 20GB+ storage
   - **Local Development Deployment**:
     - Step 1: Clone repository
     - Step 2: Copy `.env.production.template` to `.env`
     - Step 3: Fill in API keys and configuration
     - Step 4: Run `docker-compose up -d`
     - Step 5: Access dashboard at `http://localhost:5173`
     - Step 6: View logs with `docker-compose logs -f`
   - **Production VPS Deployment** (manual, no CI/CD yet):
     - Step 1: SSH to production server
     - Step 2: Install Docker + Docker Compose
     - Step 3: Clone repository (or rsync files from local)
     - Step 4: Copy production `.env` file (secure transfer, not in git)
     - Step 5: Build images: `docker-compose build`
     - Step 6: Start services: `docker-compose up -d`
     - Step 7: Verify health: `docker-compose ps` (check HEALTH status)
     - Step 8: Monitor logs: `docker-compose logs -f trading-bot`
   - **Updating Deployment** (rollout new version):
     - Step 1: Pull latest code: `git pull origin main`
     - Step 2: Rebuild images: `docker-compose build`
     - Step 3: Graceful restart: `docker-compose up -d` (recreates containers)
     - Step 4: Verify health checks pass
     - Step 5: Monitor for errors in first 5 minutes
   - **Rollback Procedure**:
     - Step 1: Identify last working commit: `git log`
     - Step 2: Checkout previous version: `git checkout <commit-hash>`
     - Step 3: Rebuild: `docker-compose build`
     - Step 4: Restart: `docker-compose up -d`
     - Step 5: Verify rollback successful
   - **Troubleshooting**:
     - Container won't start: Check logs `docker-compose logs trading-bot`
     - Health check failing: Check `/health` endpoint manually
     - Dashboard not accessible: Verify port 5173 not blocked by firewall
     - Models not loading: Check volume mounts in docker-compose.yml

2. **Create Deployment Scripts** (`scripts/deploy-local.sh`, `scripts/deploy-production.sh`):
   - **deploy-local.sh**:
     ```bash
     #!/bin/bash
     # Local development deployment
     set -e
     echo "Building Docker images..."
     docker-compose build
     echo "Starting services..."
     docker-compose up -d
     echo "Waiting for health checks..."
     sleep 30
     docker-compose ps
     echo "Deployment complete! Dashboard: http://localhost:5173"
     ```
   - **deploy-production.sh** (manual execution on production server):
     ```bash
     #!/bin/bash
     # Production deployment
     set -e

     # Safety check
     if [ ! -f .env ]; then
       echo "ERROR: .env file not found. Copy .env.production.template and configure."
       exit 1
     fi

     # Check for production flag
     if ! grep -q "TRADING_TESTNET=false" .env; then
       echo "WARNING: TRADING_TESTNET is not set to false. This will trade with REAL MONEY."
       read -p "Continue? (yes/no): " confirm
       if [ "$confirm" != "yes" ]; then
         echo "Deployment cancelled."
         exit 1
       fi
     fi

     # Build and deploy
     echo "Building production images..."
     docker-compose build
     echo "Starting production services..."
     docker-compose up -d
     echo "Waiting for health checks..."
     sleep 60
     docker-compose ps
     echo "Production deployment complete!"
     ```

3. **Create Docker Build Script** (`scripts/docker-build.sh`):
   ```bash
   #!/bin/bash
   # Build Docker images with versioning
   set -e

   VERSION=${1:-latest}
   IMAGE_NAME="llm-tradebot"

   echo "Building $IMAGE_NAME:$VERSION..."
   docker build -t $IMAGE_NAME:$VERSION -t $IMAGE_NAME:latest .

   echo "Build complete!"
   echo "Image: $IMAGE_NAME:$VERSION"
   echo "Image: $IMAGE_NAME:latest"

   # Optional: Export image for transfer
   if [ "$2" == "export" ]; then
     echo "Exporting image to tar..."
     docker save $IMAGE_NAME:$VERSION -o $IMAGE_NAME-$VERSION.tar
     echo "Exported to $IMAGE_NAME-$VERSION.tar"
   fi
   ```

4. **Create Production Checklist** (`docs/PRODUCTION_CHECKLIST.md`):
   - **Pre-Deployment**:
     - [ ] All tests passing (pytest)
     - [ ] Phase 10 monitoring tested (metrics, alerts, health checks)
     - [ ] Phase 9 safety controls tested (kill switch, circuit breaker)
     - [ ] Environment variables configured (`.env` file)
     - [ ] API keys validated (testnet → production transition)
     - [ ] Backup of current production state (if updating existing deployment)
   - **During Deployment**:
     - [ ] Docker images built successfully
     - [ ] Containers started without errors
     - [ ] Health checks passing (all services HEALTHY)
     - [ ] Dashboard accessible
     - [ ] Logs show no critical errors
   - **Post-Deployment**:
     - [ ] Monitor for 15 minutes (check for crashes, errors)
     - [ ] Verify alerts working (send test alert)
     - [ ] Verify trading activity (if applicable)
     - [ ] Verify data persistence (restart container, check state preserved)
     - [ ] Document deployment in team chat/log

5. **Update README** (modify `README.md`):
   - Add "Quick Start with Docker" section at top:
     ```markdown
     ## Quick Start with Docker

     ```bash
     # Copy environment template
     cp .env.production.template .env

     # Edit .env and add your API keys
     nano .env

     # Start with Docker Compose
     docker-compose up -d

     # View logs
     docker-compose logs -f

     # Access dashboard
     open http://localhost:5173
     ```

     For detailed deployment instructions, see [DEPLOYMENT.md](docs/DEPLOYMENT.md).
     ```
   - Add "Docker Deployment" section linking to docs/DEPLOYMENT.md

**Files to create**:
- `docs/DEPLOYMENT.md` - Comprehensive deployment documentation (~400 LOC)
- `docs/PRODUCTION_CHECKLIST.md` - Pre/during/post deployment checklist (~100 LOC)
- `scripts/deploy-local.sh` - Local deployment script (~30 LOC)
- `scripts/deploy-production.sh` - Production deployment script (~50 LOC)
- `scripts/docker-build.sh` - Docker build with versioning (~30 LOC)

**Files to modify**:
- `README.md` - Add Docker quick start section (~50 LOC)

**Estimated LOC**: ~660 lines

---

## Implementation Notes

### Docker Multi-Stage Build Strategy

**Why multi-stage?**
- PyTorch wheel is ~800MB, but we only need runtime files
- TA-Lib requires compilation (gcc, make) but build tools not needed in runtime
- Multi-stage reduces final image from ~2GB to <1GB

**Stage 1: Builder**
```dockerfile
FROM python:3.13-slim-bookworm AS builder

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc g++ make wget \
    && rm -rf /var/lib/apt/lists/*

# Install TA-Lib from source
RUN wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz && \
    tar -xzf ta-lib-0.4.0-src.tar.gz && \
    cd ta-lib && \
    ./configure --prefix=/usr && \
    make && make install && \
    cd .. && rm -rf ta-lib ta-lib-0.4.0-src.tar.gz

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --user -r requirements.txt
```

**Stage 2: Runtime**
```dockerfile
FROM python:3.13-slim-bookworm

# Copy TA-Lib libraries from builder
COPY --from=builder /usr/lib/libta_lib.* /usr/lib/
COPY --from=builder /usr/include/ta-lib/ /usr/include/ta-lib/

# Copy Python packages from builder
COPY --from=builder /root/.local /root/.local
ENV PATH=/root/.local/bin:$PATH

# Install runtime dependencies (curl for health checks)
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd -m -u 1000 tradingbot

# Copy application code
WORKDIR /app
COPY --chown=tradingbot:tradingbot trading/ ./trading/

# Switch to non-root user
USER tradingbot

# Default command (overridden in docker-compose.yml)
CMD ["python", "-m", "trading.cli", "run"]
```

### Graceful Shutdown Flow

```python
# In trading/utils/shutdown.py
class GracefulShutdownHandler:
    def handle_shutdown(self, signum, frame):
        logger.info("Shutdown signal received, initiating graceful shutdown...")

        # 1. Stop accepting new trading signals
        self.manager.paused = True

        # 2. Cancel pending orders
        for order in self.manager.provider.get_open_orders():
            self.manager.provider.cancel_order(order.id)

        # 3. Close open positions
        for position in self.manager.state.active_positions:
            self.manager.provider.close_position(
                symbol=position.symbol,
                size=position.size
            )

        # 4. Save state
        self.manager.state.save()

        # 5. Send shutdown notification
        self.manager.alert_manager.send_alert(
            "System shutdown initiated - all positions closed",
            priority="high"
        )

        # 6. Clean exit
        logger.info("Graceful shutdown complete")
        sys.exit(0)
```

### Health Check Integration with Phase 10

Phase 10 already provides comprehensive health monitoring via `/api/v1/health/status`. For Docker health checks, we create a simpler `/health` endpoint:

```python
# In trading/web/server.py
@app.get("/health")
async def health_check():
    """Lightweight health check for Docker HEALTHCHECK.

    Returns 200 if service is healthy, 503 otherwise.
    Checks:
    - FastAPI server responsive (implicit - if this runs, server is up)
    - Kill switch not active (if kill_switch available)
    - Circuit breaker not open (if circuit_breaker available)
    """
    try:
        # Check kill switch
        if self.kill_switch and self.kill_switch.is_active():
            raise HTTPException(status_code=503, detail="Kill switch active")

        # Check circuit breaker
        if self.health_monitor:
            status = self.health_monitor.get_status()
            if status.health_level == "CRITICAL":
                raise HTTPException(status_code=503, detail="System health critical")

        return {
            "status": "healthy",
            "timestamp": datetime.utcnow().isoformat()
        }

    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Health check failed: {str(e)}")
```

### Environment Variable Handling

Docker Compose loads `.env` automatically:

```yaml
# docker-compose.yml
services:
  trading-bot:
    env_file:
      - .env  # Automatically loads all variables
    environment:
      # Override specific variables for Docker environment
      DASHBOARD_HOST: "0.0.0.0"  # Bind to all interfaces
      LOG_LEVEL: "INFO"
```

**Security note**: `.env` file should NEVER be committed to git. Users must:
1. Copy `.env.production.template` to `.env`
2. Fill in actual API keys
3. Keep `.env` secure (permissions 600, encrypted backups)

### Volume Persistence Strategy

```yaml
# docker-compose.yml
volumes:
  # Application code (read-only, from host)
  - ./trading:/app/trading:ro

  # Persistent data (writable)
  - ./models:/app/models  # ML model files (.pth, .pkl)
  - ./data:/app/data      # Trade history, logs, state files

  # Environment (read-only)
  - ./.env:/app/.env:ro
```

**Why these volumes?**
- `models/` - Trained models persist across container restarts (don't retrain on every restart)
- `data/` - Trade history, logs, TradingState JSON files
- `trading/` - Hot-reload code changes during development (optional, can remove in production)

---

## Testing Strategy

### Unit Tests

**Graceful Shutdown Tests** (`trading/tests/test_shutdown.py`):
- Test signal handler registration
- Test order cancellation on shutdown
- Test position closing on shutdown
- Test state saving on shutdown
- Test timeout handling (force exit after 30s)

### Integration Tests

**Docker Build Tests** (`scripts/test-docker-build.sh`):
1. Build Docker image: `docker build -t llm-tradebot:test .`
2. Verify image size: `docker images llm-tradebot:test --format "{{.Size}}"` (expect <1GB)
3. Verify Python version: `docker run llm-tradebot:test python --version` (expect 3.13)
4. Verify TA-Lib installed: `docker run llm-tradebot:test python -c "import talib; print(talib.__version__)"`
5. Verify PyTorch installed: `docker run llm-tradebot:test python -c "import torch; print(torch.__version__)"`

**Docker Compose Tests** (`scripts/test-docker-compose.sh`):
1. Start services: `docker-compose up -d`
2. Wait for healthy: `timeout 90 bash -c 'until [ "$(docker inspect --format="{{.State.Health.Status}}" llm-tradebot-trading-bot-1)" == "healthy" ]; do sleep 5; done'`
3. Verify dashboard accessible: `curl -f http://localhost:5173/health`
4. Check logs for errors: `docker-compose logs | grep -i error` (expect none)
5. Stop services: `docker-compose down`

**Health Check Tests** (already covered in Task 2 `test-health-checks.sh`)

### Manual Testing

**Local Deployment Verification**:
1. Clone fresh repository to temporary directory
2. Copy `.env.production.template` to `.env`
3. Fill in testnet API keys
4. Run `./scripts/deploy-local.sh`
5. Verify services start and become healthy
6. Access dashboard at http://localhost:5173
7. Verify metrics displayed
8. Stop with `docker-compose down`

**Production Deployment Simulation**:
1. Spin up Ubuntu 22.04 VM (VirtualBox/cloud)
2. Install Docker + Docker Compose
3. Follow production deployment steps from `docs/DEPLOYMENT.md`
4. Verify deployment successful
5. Test graceful shutdown: `docker-compose stop`
6. Verify positions closed (check logs)
7. Restart and verify state restored

---

## Risk Mitigation

### Risk 1: Docker Image Too Large (>2GB)
- **Mitigation**: Multi-stage build reduces size by excluding build dependencies
- **Target**: <1GB final image
- **Fallback**: If still too large, use Python 3.13-alpine instead of slim-bookworm (smaller base)

### Risk 2: Model Loading Timeout During Health Check
- **Mitigation**: Set `start_period: 60s` in health check (allows 60s before first check)
- **Verification**: Test with actual model loading time
- **Fallback**: Increase start_period to 120s if needed

### Risk 3: Graceful Shutdown Doesn't Close Positions
- **Mitigation**: Comprehensive testing of shutdown handler with mock positions
- **Timeout**: Force exit after 30s to prevent hanging
- **Logging**: Detailed logs of shutdown process for debugging

### Risk 4: Environment Variables Not Loaded in Container
- **Mitigation**: Docker Compose `env_file` directive automatically loads `.env`
- **Verification**: Print environment variables on startup (masked sensitive values)
- **Fallback**: Explicitly list variables in `docker-compose.yml` environment section

### Risk 5: Volume Permissions Issues (Host vs Container UID Mismatch)
- **Mitigation**: Use UID 1000 for tradingbot user (matches most host users)
- **Verification**: Test on Linux VM (permissions most critical on Linux)
- **Fallback**: Run container as root user (less secure, but works)

---

## Definition of Done

- [ ] All 3 tasks completed
- [ ] Dockerfile builds successfully with multi-stage optimization
- [ ] Docker Compose starts all services (trading-bot, dashboard)
- [ ] Health checks pass for both services
- [ ] Graceful shutdown closes positions and saves state
- [ ] Containers auto-restart on crash
- [ ] Dashboard accessible on host machine (http://localhost:5173)
- [ ] Production deployment documentation complete (`docs/DEPLOYMENT.md`)
- [ ] Deployment scripts tested (`scripts/deploy-local.sh`)
- [ ] All integration tests pass (Docker build, Compose, health checks)
- [ ] Manual local deployment verified
- [ ] Code committed with descriptive message
- [ ] SUMMARY.md created documenting accomplishments

---

**Plan ready for execution. Expected duration: ~50-70 minutes for all 3 tasks.**
